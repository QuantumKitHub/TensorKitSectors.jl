var documenterSearchIndex = {"docs":
[{"location":"lib/#Library-documentation","page":"Library","title":"Library documentation","text":"","category":"section"},{"location":"lib/#TensorKitSectors.GroupElement","page":"Library","title":"TensorKitSectors.GroupElement","text":"const GroupElement\n\nA constant of a singleton type used as GroupElement[G] or GroupElement[G, œâ] with G <: Group a type of group, to construct or obtain a concrete subtype of AbstractElement{G} that implements the data structure used to represent elements of the group G, possibly with a second argument œâ that specifies the associated 3-cocycle.\n\n\n\n\n\n","category":"constant"},{"location":"lib/#TensorKitSectors.Irrep","page":"Library","title":"TensorKitSectors.Irrep","text":"const Irrep\n\nA constant of a singleton type used as Irrep[G] with G <: Group a type of group, to construct or obtain a concrete subtype of AbstractIrrep{G} that implements the data structure used to represent irreducible representations of the group G.\n\n\n\n\n\n","category":"constant"},{"location":"lib/#TensorKitSectors.A4Irrep","page":"Library","title":"TensorKitSectors.A4Irrep","text":"struct A4Irrep <: AbstractIrrep{A‚ÇÑ}\nA4Irrep(n::Integer)\nIrrep[A‚ÇÑ](n::Integer)\n\nRepresents irreps of the alternating group A‚ÇÑ.\n\nFields\n\nn::Int8: the label of the irrep, corresponding to 1, 1, 1 and 3.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.AbelianGroup","page":"Library","title":"TensorKitSectors.AbelianGroup","text":"abstract type AbelianGroup <: Group\n\nAbstract supertype for representing different types of Abelian groups. Abelian groups have both irreps and group elements that have several simplified properties, that can be defined in general.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.AbstractGroupElement","page":"Library","title":"TensorKitSectors.AbstractGroupElement","text":"abstract type AbstractGroupElement{G <: Group} <: Sector\n\nAbstract supertype for sectors which corresponds to group elements of a group G.\n\nActual concrete implementations of those irreps can be obtained as Element[G], or via their actual name, which generically takes the form (asciiG)Element, i.e. the ASCII spelling of the group name followed by Element.\n\nAll group elements have FusionStyle equal to UniqueFusion(). Furthermore, the BraidingStyle is set to NoBraiding(), although this can be overridden by a concrete implementation of AbstractGroupElement.\n\nFor the fusion structure, a specific SomeGroupElement <: AbstractGroupElement{SomeGroup} should only implement the following methods\n\nBase.:*(c1::GroupElement, c2::GroupElement) -> GroupElement\nBase.one(::Type{GroupElement}) -> GroupElement\nBase.inv(c::GroupElement) -> GroupElement\n# and optionally\nTensorKitSectors.cocycle(c1::GroupElement, c2::GroupElement, c3::GroupElement) -> Number\n\nThe methods conj, dual, ‚äó, Nsymbol, Fsymbol, dim, Asymbol, Bsymbol and frobenius_schur_phase will then be automatically defined. If no cocycle method is defined, the cocycle will be assumed to be trivial, i.e. equal to 1.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.AbstractIrrep","page":"Library","title":"TensorKitSectors.AbstractIrrep","text":"abstract type AbstractIrrep{G <: Group} <: Sector\n\nAbstract supertype for sectors which corresponds to irreps (irreducible representations) of a group G. As we assume unitary representations, these would be finite groups or compact Lie groups. Note that this could also include projective rather than linear representations.\n\nActual concrete implementations of those irreps can be obtained as Irrep[G], or via their actual name, which generically takes the form (asciiG)Irrep, i.e. the ASCII spelling of the group name followed by Irrep.\n\nAll irreps have BraidingStyle equal to Bosonic() and thus trivial twists.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Alternating","page":"Library","title":"TensorKitSectors.Alternating","text":"abstract type Alternating{N} <: Group\n\nType to represent the alternating group of order N!/2, which is the group of even permutations on N elements. \n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Anyonic","page":"Library","title":"TensorKitSectors.Anyonic","text":"abstract type BradingStyle\nBraidingStyle(::Sector) -> ::BraidingStyle\nBraidingStyle(I::Type{<:Sector}) -> ::BraidingStyle\n\nReturn the type of braiding and twist behavior of sectors of type I, which can be either\n\nNoBraiding(): no braiding structure\nBosonic(): symmetric braiding with trivial twist (i.e. identity)\nFermionic(): symmetric braiding with non-trivial twist (squares to identity)\nAnyonic(): general R^ab_c phase or matrix (depending on SimpleFusion or   GenericFusion fusion) and arbitrary twists\n\nNote that Bosonic and Fermionic are subtypes of SymmetricBraiding, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: isone(Rsymbol(b,a,c)*Rsymbol(a,b,c)) == true) and permutations are uniquely defined.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Bosonic","page":"Library","title":"TensorKitSectors.Bosonic","text":"abstract type BradingStyle\nBraidingStyle(::Sector) -> ::BraidingStyle\nBraidingStyle(I::Type{<:Sector}) -> ::BraidingStyle\n\nReturn the type of braiding and twist behavior of sectors of type I, which can be either\n\nNoBraiding(): no braiding structure\nBosonic(): symmetric braiding with trivial twist (i.e. identity)\nFermionic(): symmetric braiding with non-trivial twist (squares to identity)\nAnyonic(): general R^ab_c phase or matrix (depending on SimpleFusion or   GenericFusion fusion) and arbitrary twists\n\nNote that Bosonic and Fermionic are subtypes of SymmetricBraiding, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: isone(Rsymbol(b,a,c)*Rsymbol(a,b,c)) == true) and permutations are uniquely defined.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.BraidingStyle","page":"Library","title":"TensorKitSectors.BraidingStyle","text":"abstract type BradingStyle\nBraidingStyle(::Sector) -> ::BraidingStyle\nBraidingStyle(I::Type{<:Sector}) -> ::BraidingStyle\n\nReturn the type of braiding and twist behavior of sectors of type I, which can be either\n\nNoBraiding(): no braiding structure\nBosonic(): symmetric braiding with trivial twist (i.e. identity)\nFermionic(): symmetric braiding with non-trivial twist (squares to identity)\nAnyonic(): general R^ab_c phase or matrix (depending on SimpleFusion or   GenericFusion fusion) and arbitrary twists\n\nNote that Bosonic and Fermionic are subtypes of SymmetricBraiding, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: isone(Rsymbol(b,a,c)*Rsymbol(a,b,c)) == true) and permutations are uniquely defined.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.CU1Irrep","page":"Library","title":"TensorKitSectors.CU1Irrep","text":"struct CU1Irrep <: AbstractIrrep{CU‚ÇÅ}\nCU1Irrep(j, s = ifelse(j>zero(j), 2, 0))\nIrrep[CU‚ÇÅ](j, s = ifelse(j>zero(j), 2, 0))\n\nRepresents irreps of the group U‚ÇÅ  C (U‚ÇÅ and charge conjugation or reflection), which is also known as just O‚ÇÇ. \n\nFields\n\nj::HalfInt: the value of the U‚ÇÅ charge.\ns::Int: the representation of charge conjugation.\n\nThey can take values:\n\nif j == 0, s = 0 (trivial charge conjugation) or   s = 1 (non-trivial charge conjugation)\nif j > 0, s = 2 (two-dimensional representation)\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.CU‚ÇÅ","page":"Library","title":"TensorKitSectors.CU‚ÇÅ","text":"abstract type CU‚ÇÅ <: Group\n\nType to represent the group of U‚ÇÅ in combination with charge conjugation, i.e. the group generated by U‚ÇÅ and an additional element that acts as complex conjugation on U‚ÇÅ. This group is isomorphic to the orthogonal group O‚ÇÇ of real orthogonal 2√ó2 matrices, and can be seen as the semidirect product U‚ÇÅ ‚ãä ‚Ñ§‚ÇÇ. This is a compact non-Abelian group.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Cyclic","page":"Library","title":"TensorKitSectors.Cyclic","text":"abstract type Cyclic{N} <: AbelianGroup\n\nType to represent the cyclic group of order N, i.e. the multiplicative group of roots of unity of order N, which is a discrete abelian group. The cyclic group of order N is isomorphic to the additive group ‚Ñ§{N}, and we define the latter as a type alias const ‚Ñ§{N} = Cyclic{N}.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.DNIrrep","page":"Library","title":"TensorKitSectors.DNIrrep","text":"struct DNIrrep{N} <: AbstractIrrep{Dihedral{N}}\nDNIrrep{N}(n::Integer, isodd::Bool=false)\nIrrep[Dihedral{N}](n::Integer, isodd::Bool=false)\n\nRepresents irreps of the dihedral group D_N = Z_N  C (Z_N and charge conjugation or reflection).\n\nProperties\n\nj::Int: the value of the Z_N charge.\nisodd::Bool: the representation of charge conjugation.\n\nCombined these take the values +0 -0 1  (N - 1)  2 for odd N, and +0 -0 1  N  2 - 1 +(N2) -(N2) for even N, where the + (-) refer to the even (odd) one-dimensional irreps, while the others are two-dimensional.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Dihedral","page":"Library","title":"TensorKitSectors.Dihedral","text":"abstract type Dihedral{N} <: Group\n\nType to represent the dihedral group of order 2N, which is the symmetry group of a regular polygon with N sides, and is a discrete non-Abelian group. \n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.FermionNumber","page":"Library","title":"TensorKitSectors.FermionNumber","text":"const FermionNumber = U1Irrep ‚ä† FermionParity\nFermionNumber(a::Int)\n\nRepresents the fermion number as the direct product of a U‚ÇÅ irrep a and a fermion parity, with the restriction that the fermion parity is odd if and only if a is odd.\n\nSee also: U1Irrep, FermionParity\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.FermionParity","page":"Library","title":"TensorKitSectors.FermionParity","text":"struct FermionParity <: Sector\nFermionParity(isodd::Bool)\n\nRepresents sectors with fermion parity. The fermion parity is a ‚Ñ§‚ÇÇ quantum number that yields an additional sign when two odd fermions are exchanged, corresponding to a BraidingStyle that is Fermionic().\n\nFields\n\nisodd::Bool: indicates whether the fermion parity is odd (true) or even (false).\n\nSee also: FermionNumber, FermionSpin\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.FermionSpin","page":"Library","title":"TensorKitSectors.FermionSpin","text":"const FermionSpin = SU2Irrep ‚ä† FermionParity\nFermionSpin(j::Real)\n\nRepresents the fermion spin as the direct product of a SU‚ÇÇ irrep j and a fermion parity, with the restriction that the fermion parity is odd if 2 * j is odd.\n\nSee also: SU2Irrep, FermionParity\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Fermionic","page":"Library","title":"TensorKitSectors.Fermionic","text":"abstract type BradingStyle\nBraidingStyle(::Sector) -> ::BraidingStyle\nBraidingStyle(I::Type{<:Sector}) -> ::BraidingStyle\n\nReturn the type of braiding and twist behavior of sectors of type I, which can be either\n\nNoBraiding(): no braiding structure\nBosonic(): symmetric braiding with trivial twist (i.e. identity)\nFermionic(): symmetric braiding with non-trivial twist (squares to identity)\nAnyonic(): general R^ab_c phase or matrix (depending on SimpleFusion or   GenericFusion fusion) and arbitrary twists\n\nNote that Bosonic and Fermionic are subtypes of SymmetricBraiding, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: isone(Rsymbol(b,a,c)*Rsymbol(a,b,c)) == true) and permutations are uniquely defined.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.FibonacciAnyon","page":"Library","title":"TensorKitSectors.FibonacciAnyon","text":"struct FibonacciAnyon <: Sector\nFibonacciAnyon(s::Symbol)\n\nRepresents the anyons of the Fibonacci modular fusion category. It can take two values, corresponding to the trivial sector FibonacciAnyon(:I) and the non-trivial sector FibonacciAnyon(:œÑ) with fusion rules œÑ  œÑ = 1  œÑ.\n\nFields\n\nisunit::Bool: indicates whether the sector corresponds to the trivial anyon :I (true), or the non-trivial anyon :œÑ (false).\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.FusionStyle","page":"Library","title":"TensorKitSectors.FusionStyle","text":"abstract type FusionStyle\nFusionStyle(::Sector)\nFusionStyle(I::Type{<:Sector})\n\nTrait to describe the fusion behavior of sectors of type I, which can be either\n\nUniqueFusion(): single fusion output when fusing two sectors;\nSimpleFusion(): multiple outputs, but every output occurs at most one,   also known as multiplicity-free (e.g. irreps of SU(2));\nGenericFusion(): multiple outputs that can occur more than once (e.g. irreps   of SU(3)).\n\nThere is an abstract supertype MultipleFusion of which both SimpleFusion and GenericFusion are subtypes. Furthermore, there is a type alias MultiplicityFreeFusion for those fusion types which do not require muliplicity labels, i.e. MultiplicityFreeFusion = Union{UniqueFusion,SimpleFusion}.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.GenericFusion","page":"Library","title":"TensorKitSectors.GenericFusion","text":"abstract type FusionStyle\nFusionStyle(::Sector)\nFusionStyle(I::Type{<:Sector})\n\nTrait to describe the fusion behavior of sectors of type I, which can be either\n\nUniqueFusion(): single fusion output when fusing two sectors;\nSimpleFusion(): multiple outputs, but every output occurs at most one,   also known as multiplicity-free (e.g. irreps of SU(2));\nGenericFusion(): multiple outputs that can occur more than once (e.g. irreps   of SU(3)).\n\nThere is an abstract supertype MultipleFusion of which both SimpleFusion and GenericFusion are subtypes. Furthermore, there is a type alias MultiplicityFreeFusion for those fusion types which do not require muliplicity labels, i.e. MultiplicityFreeFusion = Union{UniqueFusion,SimpleFusion}.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.GenericUnit","page":"Library","title":"TensorKitSectors.GenericUnit","text":"abstract type UnitStyle\nUnitStyle(::Sector)\nUnitStyle(I::Type{<:Sector})\n\nTrait to describe the semisimplicity of the unit sector of type I. This can be either\n\nSimpleUnit(): the unit is simple (e.g. fusion categories);\nGenericUnit(): the unit is semisimple.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Group","page":"Library","title":"TensorKitSectors.Group","text":"abstract type Group\n\nAbstract supertype for representing different types of groups. Groups can be used to define Sector subtypes, either via their irreducible representations, or via their group elements, and typically appear as type parameter. As such, they are not meant to be instantiated and are defined as abstract types.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.IsingAnyon","page":"Library","title":"TensorKitSectors.IsingAnyon","text":"struct IsingAnyon <: Sector\nIsingAnyon(s::Symbol)\n\nRepresents the anyons of the Ising modular fusion category. It can take three values, corresponding to the trivial sector IsingAnyon(:I) and the non-trivial sectors IsingAnyon(:œÉ) and IsingAnyon(:œà), with fusion rules œà  œà = 1, œÉ  œà = œÉ, and œÉ  œÉ = 1  œà.\n\nFields\n\ns::Symbol: the label of the represented anyon, which can be :I, :œÉ, or :œà.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.IsingBimodule","page":"Library","title":"TensorKitSectors.IsingBimodule","text":"struct IsingBimodule <: Sector\n\nType to represent the simple objects in the Ising category reinterpreted as a bimodule category composed of two copies of the category ùíû = ùíü = Irrep[‚Ñ§‚ÇÇ], the two simple objects of which can be identified with the Ising anyons {I, œà}, and the bimodule categories ‚Ñ≥ = ‚Ñ≥·µí·µñ = Vec, with a single simple object that can be identified with the Ising anyon œÉ. This constitutes the easiest example of a multifusion category and is implemented here for testing purposes and to illustrate how to implement such categories in TensorKitSectors.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.LargeZNIrrep","page":"Library","title":"TensorKitSectors.LargeZNIrrep","text":"struct LargeZNIrrep{N} <: AbstractIrrep{‚Ñ§{N}}\nLargeZNIrrep{N}(n::Integer)\nIrrep[‚Ñ§{N}](n::Integer)\n\nRepresents irreps of the group ‚Ñ§_N for some value of N, which is typically larger than 128. For smaller values of N, the ZNIrrep sector type should be used instead. An arbitrary Integer n can be provided to the constructor, but only the value mod(n, N) is relevant.\n\nThe constructor Irrep[‚Ñ§{N}] should be preferred, as it will automatically select the most efficient storage type for a given value of N.\n\nSee also charge and modulus to extract the relevant data.\n\nFields\n\nn::UInt: the integer label of the irrep, modulo N.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.NoBraiding","page":"Library","title":"TensorKitSectors.NoBraiding","text":"abstract type BradingStyle\nBraidingStyle(::Sector) -> ::BraidingStyle\nBraidingStyle(I::Type{<:Sector}) -> ::BraidingStyle\n\nReturn the type of braiding and twist behavior of sectors of type I, which can be either\n\nNoBraiding(): no braiding structure\nBosonic(): symmetric braiding with trivial twist (i.e. identity)\nFermionic(): symmetric braiding with non-trivial twist (squares to identity)\nAnyonic(): general R^ab_c phase or matrix (depending on SimpleFusion or   GenericFusion fusion) and arbitrary twists\n\nNote that Bosonic and Fermionic are subtypes of SymmetricBraiding, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: isone(Rsymbol(b,a,c)*Rsymbol(a,b,c)) == true) and permutations are uniquely defined.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.PlanarTrivial","page":"Library","title":"TensorKitSectors.PlanarTrivial","text":"struct PlanarTrivial <: Sector\nPlanarTrivial()\n\nRepresents a trivial anyon sector, i.e. a trivial sector without braiding. This is mostly useful for testing.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.ProductGroup","page":"Library","title":"TensorKitSectors.ProductGroup","text":"abstract type ProductGroup{T <: Tuple{Vararg{Group}}} <: Group\n\nType to represent the direct product of a tuple of groups. This is typically constructed via the √ó operator.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.ProductSector","page":"Library","title":"TensorKitSectors.ProductSector","text":"struct ProductSector{T <: SectorTuple}\nProductSector((s‚ÇÅ, s‚ÇÇ, ...))\n\nRepresents the Deligne tensor product of sectors. The type parameter T is a tuple of the component sectors. The recommended way to construct a ProductSector is using the deligneproduct (‚ä†) operator on the components.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.SU","page":"Library","title":"TensorKitSectors.SU","text":"abstract type SU{N} <: Group\n\nType to represent the special unitary group SU(N), which is a compact non-Abelian Lie group.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.SU2Irrep","page":"Library","title":"TensorKitSectors.SU2Irrep","text":"struct SU2Irrep <: AbstractIrrep{SU‚ÇÇ}\nSU2Irrep(j::Real)\nIrrep[SU‚ÇÇ](j::Real)\n\nRepresents irreps of the group SU‚ÇÇ. The irrep is labelled by a half integer j which can be entered as an abitrary Real, but is stored as a HalfInt from the HalfIntegers.jl package.\n\nFields\n\nj::HalfInt: the label of the irrep, which can be any non-negative half integer.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Sector","page":"Library","title":"TensorKitSectors.Sector","text":"abstract type Sector\n\nAbstract type for representing the (isomorphism classes of) simple objects in (unitary and pivotal) (pre-)fusion categories, e.g. the irreducible representations of a finite or compact group. Subtypes I <: Sector as the set of labels of a GradedSpace.\n\nEvery new I <: Sector should implement the following methods:\n\nunit(::Type{I}): unit element of I. If there are multiple, implement allunits(::Type{I})   instead.\ndual(a::I): aÃÖ, conjugate or dual label of a\n‚äó(a::I, b::I): iterable with unique fusion outputs of a  b   (i.e. don't repeat in case of multiplicities)\nNsymbol(a::I, b::I, c::I): number of times c appears in a ‚äó b, i.e. the   multiplicity\nFusionStyle(::Type{I}): UniqueFusion(), SimpleFusion() or   GenericFusion()\nBraidingStyle(::Type{I}): Bosonic(), Fermionic(), Anyonic(), ...\nFsymbol(a::I, b::I, c::I, d::I, e::I, f::I): F-symbol: scalar (in case of   UniqueFusion/SimpleFusion) or rank-4 array (in case of GenericFusion)\nRsymbol(a::I, b::I, c::I): R-symbol: scalar (in case of   UniqueFusion/SimpleFusion) or matrix (in case of GenericFusion)\nisless(a::I, b::I): defines a canonical ordering of sectors\nhash(a::I): hash function for sectors\n\nand optionally\n\ndim(a::I): quantum dimension of sector a\nfrobenius_schur_indicator(a::I): Frobenius-Schur indicator of a (1, 0, -1)\nfrobenius_schur_phase(a::I): Frobenius-Schur phase of a (¬±1)\nsectorscalartype(::Type{I}): scalar type of F- and R-symbols\nBsymbol(a::I, b::I, c::I): B-symbol: scalar (in case of   UniqueFusion/SimpleFusion) or matrix (in case of GenericFusion)\ntwist(a::I) -> twist of sector a\n\nFurthermore, iterate and Base.IteratorSize should be made to work for the singleton type SectorValues{I}.\n\nTo help with the implementation of ‚äó(a::I, b::I) as an iterator, the provided struct type SectorProductIterator{I} can be used, which stores a and b and requires the implementation of Base.iterate(::SectorProductIterator{I}, state...).\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.SectorProductIterator","page":"Library","title":"TensorKitSectors.SectorProductIterator","text":"struct SectorProductIterator{I <: Sector}\nSectorProductIterator(a::I, b::I) where {I <: Sector}\n\nCustom iterator to represent the (unique) fusion outputs of a  b.\n\nCustom sectors that aim to use this have to provide the following functionality:\n\nBase.iterate(::SectorProductIterator{I}, state...) where {I <: Sector}: iterate over   the fusion outputs of a ‚äó b\n\nIf desired and it is possible to easily compute the number of unique fusion outputs, it is also possible to define Base.IteratorSize(::Type{SectorProductIterator{I}}) = Base.HasLength(), in which case Base.length(::SectorProductIterator{I}) has to be implemented.\n\nSee also ‚äó.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.SectorValues","page":"Library","title":"TensorKitSectors.SectorValues","text":"struct SectorValues{I <: Sector}\n\nSingleton type to represent an iterator over the possible values of type I, whose instance is obtained as values(I). For a new I::Sector, the following should be defined\n\nBase.iterate(::SectorValues{I}[, state]): iterate over the values\nBase.IteratorSize(::Type{SectorValues{I}}): HasLength(), SizeUnknown()   or IsInfinite() depending on whether the number of values of type I is finite   (and sufficiently small) or infinite; for a large number of values, SizeUnknown() is   recommended because this will trigger the use of GenericGradedSpace.\n\nIf IteratorSize(I) == HasLength(), also the following must be implemented:\n\nBase.length(::SectorValues{I}): the number of different values\nBase.getindex(::SectorValues{I}, i::Int): a mapping between an index i and an   instance of I. A fallback implementation exists that returns the ith value   of the SectorValues iterator.\nfindindex(::SectorValues{I}, c::I): reverse mapping between a value c::I and an   index i::Integer ‚àà 1:length(values(I)). A fallback implementation exists that   linearly searches through the SectorValues iterator.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.SimpleFusion","page":"Library","title":"TensorKitSectors.SimpleFusion","text":"abstract type FusionStyle\nFusionStyle(::Sector)\nFusionStyle(I::Type{<:Sector})\n\nTrait to describe the fusion behavior of sectors of type I, which can be either\n\nUniqueFusion(): single fusion output when fusing two sectors;\nSimpleFusion(): multiple outputs, but every output occurs at most one,   also known as multiplicity-free (e.g. irreps of SU(2));\nGenericFusion(): multiple outputs that can occur more than once (e.g. irreps   of SU(3)).\n\nThere is an abstract supertype MultipleFusion of which both SimpleFusion and GenericFusion are subtypes. Furthermore, there is a type alias MultiplicityFreeFusion for those fusion types which do not require muliplicity labels, i.e. MultiplicityFreeFusion = Union{UniqueFusion,SimpleFusion}.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.SimpleUnit","page":"Library","title":"TensorKitSectors.SimpleUnit","text":"abstract type UnitStyle\nUnitStyle(::Sector)\nUnitStyle(I::Type{<:Sector})\n\nTrait to describe the semisimplicity of the unit sector of type I. This can be either\n\nSimpleUnit(): the unit is simple (e.g. fusion categories);\nGenericUnit(): the unit is semisimple.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.TimeReversed","page":"Library","title":"TensorKitSectors.TimeReversed","text":"struct TimeReversed{I <: Sector}\nTimeReversed(a::I) where {I <: Sector}\n\nRepresents the time-reversed version of the sector I, i.e. the sector with the same fusion rules and F-symbols, but with the inverse braiding.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Trivial","page":"Library","title":"TensorKitSectors.Trivial","text":"struct Trivial <: Sector\nTrivial()\n\nSingleton type to represent the trivial sector, i.e. the trivial representation of the trivial group. This is equivalent to Rep[‚Ñ§‚ÇÅ], or the unit object of the category Vect of ordinary vector spaces.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.U1Irrep","page":"Library","title":"TensorKitSectors.U1Irrep","text":"struct U1Irrep <: AbstractIrrep{U‚ÇÅ}\nU1Irrep(charge::Real)\nIrrep[U‚ÇÅ](charge::Real)\n\nRepresents irreps of the group U‚ÇÅ. The irrep is labelled by a charge, which should be an integer for a linear representation. However, it is often useful to allow half integers to represent irreps of U‚ÇÅ subgroups of SU‚ÇÇ, such as the S^z of spin-1/2 system. Hence, the charge is stored as a HalfInt from the package HalfIntegers.jl, but can be entered as arbitrary Real. The sequence of the charges is: 0, 1/2, -1/2, 1, -1, ...\n\nFields\n\ncharge::HalfInt: the label of the irrep, which can be any half integer.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.UniqueFusion","page":"Library","title":"TensorKitSectors.UniqueFusion","text":"abstract type FusionStyle\nFusionStyle(::Sector)\nFusionStyle(I::Type{<:Sector})\n\nTrait to describe the fusion behavior of sectors of type I, which can be either\n\nUniqueFusion(): single fusion output when fusing two sectors;\nSimpleFusion(): multiple outputs, but every output occurs at most one,   also known as multiplicity-free (e.g. irreps of SU(2));\nGenericFusion(): multiple outputs that can occur more than once (e.g. irreps   of SU(3)).\n\nThere is an abstract supertype MultipleFusion of which both SimpleFusion and GenericFusion are subtypes. Furthermore, there is a type alias MultiplicityFreeFusion for those fusion types which do not require muliplicity labels, i.e. MultiplicityFreeFusion = Union{UniqueFusion,SimpleFusion}.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.UnitStyle","page":"Library","title":"TensorKitSectors.UnitStyle","text":"abstract type UnitStyle\nUnitStyle(::Sector)\nUnitStyle(I::Type{<:Sector})\n\nTrait to describe the semisimplicity of the unit sector of type I. This can be either\n\nSimpleUnit(): the unit is simple (e.g. fusion categories);\nGenericUnit(): the unit is semisimple.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.U‚ÇÅ","page":"Library","title":"TensorKitSectors.U‚ÇÅ","text":"abstract type U‚ÇÅ <: AbelianGroup\n\nType to represent the group U(1) of complex numbers of unit modulus, which is a compact Abelian Lie group.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.ZNElement","page":"Library","title":"TensorKitSectors.ZNElement","text":"struct ZNElement{N, p} <: AbstractGroupElement{‚Ñ§{N}}\nZNElement{N, p}(n::Integer)\nGroupElement[‚Ñ§{N}, p](n::Integer)\n\nRepresents an element of the group ‚Ñ§_N for some value of N < 64. (We need 2 * (N - 1) <= 127 in order for a ‚äó b to work correctly.) For N equals 2, 3 or 4, ‚Ñ§{N} can be replaced by ‚Ñ§‚ÇÇ, ‚Ñ§‚ÇÉ, ‚Ñ§‚ÇÑ. An arbitrary Integer n can be provided to the constructor, but only the value mod(n, N) is relevant. The second type parameter p should also be specified as an integer 0 <= p < N and specifies the 3-cocycle, which is then being given by\n\ncocycle(a, b, c) = cispi(2 * p * a.n * (b.n + c.n - mod(b.n + c.n, N)) / N))\n\nIf p is not specified, it defaults to 0, i.e. the trivial cocycle.\n\nFields\n\nn::Int8: the integer label of the element, modulo N.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.ZNIrrep","page":"Library","title":"TensorKitSectors.ZNIrrep","text":"struct ZNIrrep{N} <: AbstractIrrep{‚Ñ§{N}}\nZNIrrep{N}(n::Integer)\nIrrep[‚Ñ§{N}](n::Integer)\n\nRepresents irreps of the group ‚Ñ§_N for some value of N. For N equals 2, 3 or 4, ‚Ñ§{N} can be replaced by ‚Ñ§‚ÇÇ, ‚Ñ§‚ÇÉ, and ‚Ñ§‚ÇÑ. An arbitrary Integer n can be provided to the constructor, but only the value mod(n, N) is relevant.\n\nThe type of the stored integer (UInt8) requires N ‚â§ 128. Larger values of N should use the LargeZNIrrep instead. The constructor Irrep[‚Ñ§{N}] should be preferred, as it will automatically select the most efficient storage type for a given value of N.\n\nSee also charge and modulus to extract the relevant data.\n\nFields\n\nn::UInt8: the integer label of the irrep, modulo N.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Base.isreal-Tuple{Type{<:Sector}}","page":"Library","title":"Base.isreal","text":"isreal(::Type{<:Sector}) -> Bool\n\nReturn whether the topological data (Fsymbol, Rsymbol) of the sector is real or not (in which case it is complex).\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.:√ó-Tuple{Vararg{Type{<:Group}}}","page":"Library","title":"TensorKitSectors.:√ó","text":"√ó(G::Vararg{Type{<:Group}}) -> ProductGroup{Tuple{G...}}\ntimes(G::Vararg{Type{<:Group}}) -> ProductGroup{Tuple{G...}}\n\nConstruct the direct product of a (list of) groups.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.:‚äó","page":"Library","title":"TensorKitSectors.:‚äó","text":"‚äó(a::I, b::I...) where {I <: Sector}\notimes(a::I, b::I...) where {I <: Sector}\n\nReturn an iterable of elements of c::I that appear in the fusion product a ‚äó b.\n\nNote that every element c should appear at most once, fusion degeneracies (if FusionStyle(I) == GenericFusion()) should be accessed via Nsymbol(a, b, c).\n\n\n\n\n\n","category":"function"},{"location":"lib/#TensorKitSectors.:‚ä†-Tuple{Sector, Sector}","page":"Library","title":"TensorKitSectors.:‚ä†","text":"‚ä†(s‚ÇÅ::Sector, s‚ÇÇ::Sector)\ndeligneproduct(s‚ÇÅ::Sector, s‚ÇÇ::Sector)\n\nGiven two sectors s‚ÇÅ and s‚ÇÇ, which label an isomorphism class of simple objects in a fusion category C‚ÇÅ and C‚ÇÇ, s1 ‚ä† s2 (obtained as \\boxtimes+TAB) labels the isomorphism class of simple objects in the Deligne tensor product category C‚ÇÅ  C‚ÇÇ.\n\nThe Deligne tensor product also works in the type domain and for spaces and tensors. For group representations, we have Irrep[G‚ÇÅ] ‚ä† Irrep[G‚ÇÇ] == Irrep[G‚ÇÅ √ó G‚ÇÇ].\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.Asymbol-Union{Tuple{I}, Tuple{I, I, I}} where I<:Sector","page":"Library","title":"TensorKitSectors.Asymbol","text":"Asymbol(a::I, b::I, c::I) where {I <: Sector}\n\nReturn the value of A^ab_c which appears in transforming a splitting vertex into a fusion vertex using the transformation\n\na -<-Œº-<- c                                                    b -<-ŒΩ-<- dual(a)\n     ‚à®       -> ‚àö(dim(c) / dim(b)) * Asymbol(a, b, c)[Œº, ŒΩ]         ‚àß\n     b                                                              c\n\nIf FusionStyle(I) is UniqueFusion() or SimpleFusion(), the A-symbol is a number. Otherwise it is a square matrix with row and column size Nsymbol(a, b, c) == Nsymbol(dual(a), c, b).\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.Bsymbol-Union{Tuple{I}, Tuple{I, I, I}} where I<:Sector","page":"Library","title":"TensorKitSectors.Bsymbol","text":"Bsymbol(a::I, b::I, c::I) where {I <: Sector}\n\nReturn the value of B^ab_c which appears in transforming a splitting vertex into a fusion vertex using the transformation\n\na -<-Œº-<- c                                                    a -<-ŒΩ-<- c\n     ‚à®       -> ‚àö(dim(c) / dim(a)) * Bsymbol(a, b, c)[Œº, ŒΩ]         ‚àß\n     b                                                            dual(b)\n\nIf FusionStyle(I) is UniqueFusion() or SimpleFusion(), the B-symbol is a number. Otherwise it is a square matrix with row and column size Nsymbol(a, b, c) == Nsymbol(c, dual(b), a).\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.Fsymbol","page":"Library","title":"TensorKitSectors.Fsymbol","text":"Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I <: Sector}\n\nReturn the F-symbol F^abc_d that associates the two different fusion orders of sectors a, b and c into an ouput sector d, using either an intermediate sector a  b  e or b  c  f:\n\na-<-Œº-<-e-<-ŒΩ-<-d                                     a-<-Œª-<-d\n    ‚à®       ‚à®       -> Fsymbol(a,b,c,d,e,f)[Œº,ŒΩ,Œ∫,Œª]      ‚à®\n    b       c                                             f\n                                                          v\n                                                      b-<-Œ∫\n                                                          ‚à®\n                                                          c\n\nIf FusionStyle(I) is UniqueFusion or SimpleFusion, the F-symbol is a number. Otherwise it is a rank 4 array of size (Nsymbol(a, b, e), Nsymbol(e, c, d), Nsymbol(b, c, f), Nsymbol(a, f, d)).\n\n\n\n\n\n","category":"function"},{"location":"lib/#TensorKitSectors.Nsymbol","page":"Library","title":"TensorKitSectors.Nsymbol","text":"Nsymbol(a::I, b::I, c::I) where {I <: Sector} -> Integer\n\nReturn an Integer representing the number of times c appears in the fusion product a ‚äó b. Could be a Bool if FusionStyle(I) == UniqueFusion() or SimpleFusion().\n\n\n\n\n\n","category":"function"},{"location":"lib/#TensorKitSectors.Rsymbol","page":"Library","title":"TensorKitSectors.Rsymbol","text":"Rsymbol(a::I, b::I, c::I) where {I <: Sector}\n\nReturns the R-symbol R^ab_c that maps between c  a  b and c  b  a as in\n\na -<-Œº-<- c                                 b -<-ŒΩ-<- c\n     ‚à®        -> Rsymbol(a, b, c)[Œº, ŒΩ]          v\n     b                                           a\n\nIf FusionStyle(I) is UniqueFusion() or SimpleFusion(), the R-symbol is a number. Otherwise it is a square matrix with row and column size Nsymbol(a, b, c) == Nsymbol(b, a, c).\n\n\n\n\n\n","category":"function"},{"location":"lib/#TensorKitSectors.allunits-Union{Tuple{Type{I}}, Tuple{I}} where I<:Sector","page":"Library","title":"TensorKitSectors.allunits","text":"allunits(I::Type{<:Sector}) -> Tuple{I}\n\nReturn a tuple with all units of the sector type I. For fusion categories, this will contain only one element.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.braidingscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I<:Sector","page":"Library","title":"TensorKitSectors.braidingscalartype","text":"braidingscalartype(I::Type{<:Sector}) -> Type{<:Number}\n\nReturn the scalar type of the topological data associated to braiding of the sector I. In particular, this is the scalar type of Rsymbol.\n\nSee also fusionscalartype and sectorscalartype.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.charge-Tuple{U1Irrep}","page":"Library","title":"TensorKitSectors.charge","text":"charge(c::U1Irrep) -> HalfInt\n\nThe charge label of the irrep c.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.charge-Tuple{Union{LargeZNIrrep{N}, ZNIrrep{N}} where N}","page":"Library","title":"TensorKitSectors.charge","text":"charge(c::ZNIrrep) -> Int\n\nThe charge label of the irrep c.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.dim-Tuple{Sector}","page":"Library","title":"TensorKitSectors.dim","text":"dim(a::Sector)\n\nReturn the (quantum) dimension of the sector a.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.dimscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I<:Sector","page":"Library","title":"TensorKitSectors.dimscalartype","text":"dimscalartype(::Type{<:Sector}) -> Type{<:Number}\n\nReturn the scalar type of the quantum dimensions associated to sectors of type I. In particular, this is the scalar type of dim.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.dual-Tuple{Sector}","page":"Library","title":"TensorKitSectors.dual","text":"dual(a::Sector) -> Sector\n\nReturn the dual label of a, i.e. the unique label aÃÑ = dual(a) such that  Nsymbol(a, aÃÑ, leftunit(a)) == 1 and Nsymbol(aÃÑ, a, rightunit(a)) == 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.findindex-Union{Tuple{I}, Tuple{SectorValues{I}, I}} where I<:Sector","page":"Library","title":"TensorKitSectors.findindex","text":"findindex(v::SectorValues{I}, c::I)\n\nReverse mapping between a value c::I and an index i::Integer ‚àà 1:length(values(I)).\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.frobenius_schur_indicator-Tuple{Sector}","page":"Library","title":"TensorKitSectors.frobenius_schur_indicator","text":"frobenius_schur_indicator(a::Sector)\n\nReturn the Frobenius-Schur indicator of a sector ŒΩ‚Çê  1 0 -1, which distinguishes between real, complex and quaternionic representations.\n\nSee also frobenius_schur_phase for the category-theoretic version that appears in the context of line bending.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.frobenius_schur_phase-Tuple{Sector}","page":"Library","title":"TensorKitSectors.frobenius_schur_phase","text":"frobenius_schur_phase(a::Sector)\n\nReturn the Frobenius-Schur phase Œ∫‚Çê of a sector a, which is a complex phase that appears in the context of bending lines and is obtained from F^a aÃÖ a_a. When a == dual(a), it is restricted to Œ∫‚Çê  1 -1 and coincides with the group-theoretic version frobenius_schur_indicator. When a != dual(a), the value of Œ∫‚Çê can be gauged to be 1, though is not required to be.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.fusionscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I<:Sector","page":"Library","title":"TensorKitSectors.fusionscalartype","text":"fusionscalartype(I::Type{<:Sector}) -> Type{<:Number}\n\nReturn the scalar type of the topological data associated to fusion of the sector I. In particular, this is the scalar type of Fsymbol.\n\nSee also braidingscalartype and sectorscalartype.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.fusiontensor-Union{Tuple{I}, Tuple{I, I, I}} where I<:Sector","page":"Library","title":"TensorKitSectors.fusiontensor","text":"fusiontensor(a::I, b::I, c::I) where {I <: Sector} -> AbstractArray{T, 4}\n\nReturn the fusion tensor for the fusion a ‚äó b -> c. The dimensions of the returned array are (dim(a), dim(b), dim(c), Nsymbol(a, b, c)). The components of the fusion tensor are simply the Clebsch-Gordan coefficients, describing the unitary basis change from the tensor product of irreps a and b to the coupled irrep c.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.hexagon_equation-Union{Tuple{I}, Tuple{I, I, I}} where I<:Sector","page":"Library","title":"TensorKitSectors.hexagon_equation","text":"hexagon_equation(a::I, b::I, c::I; kwargs...) where {I <: Sector} -> Bool\n\nCheck whether the hexagon equations hold for braiding the sector a around the fusion product of b and c along the two different paths. There are two hexagon equations, one for braiding a over b ‚äó c and one for braiding a under b ‚äó c.\n\nIf kwargs are provided, they are forwarded to isapprox when comparing the two sides of the hexagon equations.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.isunit-Tuple{Sector}","page":"Library","title":"TensorKitSectors.isunit","text":"isunit(a::Sector) -> Bool\n\nReturn whether sector a is a unit element.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.leftunit-Tuple{Sector}","page":"Library","title":"TensorKitSectors.leftunit","text":"leftunit(a::Sector) -> Sector\n\nReturn the left unit element corresponding to a; this is necessary for multifusion categories, where the unit may not be unique. See also rightunit and unit.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.modulus-Tuple{Union{LargeZNIrrep{N}, ZNIrrep{N}} where N}","page":"Library","title":"TensorKitSectors.modulus","text":"modulus(c::ZNIrrep{N}) -> N\nmodulus(::Type{<:ZNIrrep{N}}) -> N\n\nThe order of the cyclic group, or the modulus of the charge labels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.pentagon_equation-Union{Tuple{I}, NTuple{4, I}} where I<:Sector","page":"Library","title":"TensorKitSectors.pentagon_equation","text":"pentagon_equation(a::I, b::I, c::I, d::I; kwargs...) where {I <: Sector} -> Bool\n\nCheck whether the pentagon equation holds for fusing the sectors a, b, c and d to each of their sectors along the two different fusion paths.\n\nIf kwargs are provided, they are forwarded to isapprox when comparing the two sides of the pentagon equation.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.precompile_sector-Union{Tuple{Type{I}}, Tuple{I}} where I<:Sector","page":"Library","title":"TensorKitSectors.precompile_sector","text":"precompile_sector(I::Type{<:Sector})\n\nPrecompile common methods for the given sector type.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.rightunit-Tuple{Sector}","page":"Library","title":"TensorKitSectors.rightunit","text":"rightunit(a::Sector) -> Sector\n\nReturn the right unit element corresponding to a; this is necessary for multifusion categories, where the unit may not be unique. See also leftunit and unit.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.sectorscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I<:Sector","page":"Library","title":"TensorKitSectors.sectorscalartype","text":"sectorscalartype(I::Type{<:Sector}) -> Type{<:Number}\n\nReturn the scalar type of the topological data of the sector I. In particular, this is a combination of the scalar type of both the Fsymbol and Rsymbol, and determines the scalar type of the fusiontensor whenever it is defined.\n\nSee also fusionscalartype and braidingscalartype.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.twist-Tuple{Sector}","page":"Library","title":"TensorKitSectors.twist","text":"twist(a::Sector)\n\nReturn the twist of a sector a.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.type_repr-Tuple{Type}","page":"Library","title":"TensorKitSectors.type_repr","text":"type_repr(T::Type)\n\nReturn a string representation of the type T, which is used to modify the default way in which Sector subtypes are displayed in other objects that depend on them.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.unit-Tuple{Sector}","page":"Library","title":"TensorKitSectors.unit","text":"unit(::Sector) -> Sector\nunit(::Type{<:Sector}) -> Sector\n\nReturn the unit element of this type of sector, provided it is unique.\n\n\n\n\n\n","category":"method"},{"location":"#TensorKitSectors.jl","page":"Home","title":"TensorKitSectors.jl","text":"A Julia package for working with objects in fusion categories.\n\nThis package provides functionality for defining objects in fusion categories, along with their topological data. This includes the fusion rules, the associators, and the braiding. In particular, this is the data that is needed to define (symmetric) tensors, which are defined over vector spaces graded by these objects. For the full functionality, we refer to TensorKit.jl and its documentation.\n\nInstall via the package manager.","category":"section"}]
}
