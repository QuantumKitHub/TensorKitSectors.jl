var documenterSearchIndex = {"docs":
[{"location":"sectors/nonabelian/a4/#Alternating-Group-A:-A4Irrep","page":"A‚ÇÑ (Alternating)","title":"Alternating Group A‚ÇÑ: A4Irrep","text":"","category":"section"},{"location":"sectors/nonabelian/a4/#Type-Definition","page":"A‚ÇÑ (Alternating)","title":"Type Definition","text":"","category":"section"},{"location":"sectors/nonabelian/a4/#Construction","page":"A‚ÇÑ (Alternating)","title":"Construction","text":"","category":"section"},{"location":"sectors/nonabelian/a4/#Labels","page":"A‚ÇÑ (Alternating)","title":"Labels","text":"","category":"section"},{"location":"sectors/nonabelian/a4/#Physical-Interpretation","page":"A‚ÇÑ (Alternating)","title":"Physical Interpretation","text":"","category":"section"},{"location":"sectors/nonabelian/a4/#Fusion-Rules","page":"A‚ÇÑ (Alternating)","title":"Fusion Rules","text":"","category":"section"},{"location":"sectors/nonabelian/a4/#Quantum-Dimensions","page":"A‚ÇÑ (Alternating)","title":"Quantum Dimensions","text":"","category":"section"},{"location":"sectors/nonabelian/a4/#Topological-Data","page":"A‚ÇÑ (Alternating)","title":"Topological Data","text":"","category":"section"},{"location":"sectors/nonabelian/a4/#F-symbols","page":"A‚ÇÑ (Alternating)","title":"F-symbols","text":"","category":"section"},{"location":"sectors/nonabelian/a4/#R-symbols","page":"A‚ÇÑ (Alternating)","title":"R-symbols","text":"","category":"section"},{"location":"sectors/nonabelian/a4/#Braiding-Style","page":"A‚ÇÑ (Alternating)","title":"Braiding Style","text":"","category":"section"},{"location":"sectors/nonabelian/a4/#Basis-Conventions","page":"A‚ÇÑ (Alternating)","title":"Basis Conventions","text":"","category":"section"},{"location":"sectors/nonabelian/a4/#Iteration","page":"A‚ÇÑ (Alternating)","title":"Iteration","text":"","category":"section"},{"location":"sectors/nonabelian/a4/#Code-Examples","page":"A‚ÇÑ (Alternating)","title":"Code Examples","text":"","category":"section"},{"location":"sectors/nonabelian/a4/#Implementation-Notes","page":"A‚ÇÑ (Alternating)","title":"Implementation Notes","text":"","category":"section"},{"location":"interface/overview/#Sector-Interface","page":"Overview","title":"Sector Interface","text":"","category":"section"},{"location":"interface/overview/#Introduction","page":"Overview","title":"Introduction","text":"A Sector is a label for the different symmetry charges or quantum numbers that organize graded vector spaces. In particular, these are the labels use to decompose vector spaces as:\n\nV = bigoplus_a in textSectors mathbbC^n_a otimes V_a\n\nwhere n_a is the multiplicity of sector a and V_a is the associated vector space.\n\nSectors encode the structural rules TensorKit needs:\n\nObjects: the labels themselves (irreps, anyons, ‚Ä¶)\nFusion rules: which labels appear in a otimes b rightarrow bigoplus_c N^ab_c c\nAssociativity: how different parenthesizations are related\nBraiding: how labels behave under exchange (if supported)\n\nMore rigorously, a Sector represents the isomorphism classes of simple objects in unitary and pivotal fusion categories. This package defines an interface for accessing the topological data that is associated to these categories. This section explains the required and optional methods needed to create a new sector type. Once this interface is fulfilled, TensorKit.jl will create symmetric tensors that correspond to the implemented sector.","category":"section"},{"location":"interface/overview/#Organization","page":"Overview","title":"Organization","text":"The interface documentation is divided into several pages:\n\nRequired Methods: The minimum interface needed for a valid sector type\nOptional Methods: Additional methods with default implementations that can be specialized\nTraits and Styles: Compile-time properties that control behavior and optimizations\nImplementation Guidelines: Practical advice and helper types for implementing sectors","category":"section"},{"location":"lib/#Library-documentation","page":"Library","title":"Library documentation","text":"","category":"section"},{"location":"lib/#TensorKitSectors.GroupElement","page":"Library","title":"TensorKitSectors.GroupElement","text":"const GroupElement\n\nA constant of a singleton type used as GroupElement[G] or GroupElement[G, œâ] with G <: Group a type of group, to construct or obtain a concrete subtype of AbstractElement{G} that implements the data structure used to represent elements of the group G, possibly with a second argument œâ that specifies the associated 3-cocycle.\n\n\n\n\n\n","category":"constant"},{"location":"lib/#TensorKitSectors.Irrep","page":"Library","title":"TensorKitSectors.Irrep","text":"const Irrep\n\nA constant of a singleton type used as Irrep[G] with G <: Group a type of group, to construct or obtain a concrete subtype of AbstractIrrep{G} that implements the data structure used to represent irreducible representations of the group G.\n\n\n\n\n\n","category":"constant"},{"location":"lib/#TensorKitSectors.MultiplicityFreeFusion","page":"Library","title":"TensorKitSectors.MultiplicityFreeFusion","text":"const MultiplicityFreeFusion = Union{UniqueFusion, SimpleFusion}\n\nConvenience alias for fusion styles that can assume Nsymbol(a, b, c)::Bool, and therefore never require multiplicity labels.\n\nSee also UniqueFusion, SimpleFusion and FusionStyle.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.A4Irrep","page":"Library","title":"TensorKitSectors.A4Irrep","text":"struct A4Irrep <: AbstractIrrep{A‚ÇÑ}\nA4Irrep(n::Integer)\nIrrep[A‚ÇÑ](n::Integer)\n\nRepresents irreps of the alternating group A‚ÇÑ.\n\nFields\n\nn::Int8: the label of the irrep, corresponding to 1, 1, 1 and 3.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.AbelianGroup","page":"Library","title":"TensorKitSectors.AbelianGroup","text":"abstract type AbelianGroup <: Group\n\nAbstract supertype for representing different types of Abelian groups. Abelian groups have both irreps and group elements that have several simplified properties, that can be defined in general.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.AbstractGroupElement","page":"Library","title":"TensorKitSectors.AbstractGroupElement","text":"abstract type AbstractGroupElement{G <: Group} <: Sector\n\nAbstract supertype for sectors which corresponds to group elements of a group G.\n\nActual concrete implementations of those irreps can be obtained as Element[G], or via their actual name, which generically takes the form (asciiG)Element, i.e. the ASCII spelling of the group name followed by Element.\n\nAll group elements have FusionStyle equal to UniqueFusion(). Furthermore, the BraidingStyle is set to NoBraiding(), although this can be overridden by a concrete implementation of AbstractGroupElement.\n\nFor the fusion structure, a specific SomeGroupElement <: AbstractGroupElement{SomeGroup} should only implement the following methods\n\nBase.:*(c1::GroupElement, c2::GroupElement) -> GroupElement\nBase.one(::Type{GroupElement}) -> GroupElement\nBase.inv(c::GroupElement) -> GroupElement\n# and optionally\nTensorKitSectors.cocycle(c1::GroupElement, c2::GroupElement, c3::GroupElement) -> Number\n\nThe methods conj, dual, ‚äó, Nsymbol, Fsymbol, dim, Asymbol, Bsymbol and frobenius_schur_phase will then be automatically defined. If no cocycle method is defined, the cocycle will be assumed to be trivial, i.e. equal to 1.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.AbstractIrrep","page":"Library","title":"TensorKitSectors.AbstractIrrep","text":"abstract type AbstractIrrep{G <: Group} <: Sector\n\nAbstract supertype for sectors which corresponds to irreps (irreducible representations) of a group G. As we assume unitary representations, these would be finite groups or compact Lie groups. Note that this could also include projective rather than linear representations.\n\nActual concrete implementations of those irreps can be obtained as Irrep[G], or via their actual name, which generically takes the form (asciiG)Irrep, i.e. the ASCII spelling of the group name followed by Irrep.\n\nAll irreps have BraidingStyle equal to Bosonic() and thus trivial twists.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Alternating","page":"Library","title":"TensorKitSectors.Alternating","text":"abstract type Alternating{N} <: Group\n\nType to represent the alternating group of order N!/2, which is the group of even permutations on N elements. \n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Anyonic","page":"Library","title":"TensorKitSectors.Anyonic","text":"struct Anyonic <: HasBraiding\n\nBraiding style with general (non-symmetric) braiding and arbitrary twists. Characterized by nontrivial braid group representations where R^ab_c R^ba_c  1 in general.\n\nSee also BraidingStyle.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Bosonic","page":"Library","title":"TensorKitSectors.Bosonic","text":"struct Bosonic <: SymmetricBraiding\n\nBraiding style with symmetric braiding and trivial twist. This is characterized by R^ab_c R^ba_c = 1 and theta_a = 1 for all sectors.\n\nSee also BraidingStyle.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.BraidingStyle","page":"Library","title":"TensorKitSectors.BraidingStyle","text":"abstract type BraidingStyle\nBraidingStyle(::Sector) -> ::BraidingStyle\nBraidingStyle(I::Type{<:Sector}) -> ::BraidingStyle\n\nTrait to describe the braiding behavior of sectors of type I, which can be either\n\nNoBraiding: no braiding structure defined.\nBosonic: symmetric braiding structure with a trivial twist.\nFermionic: symmetric braiding structure with a non-trivial twist that squares to identity.\nAnyonic: general braiding structure and arbitrary twists.\n\nThere is an abstract supertype HasBraiding that includes all styles that define Rsymbol (everything but NoBraiding). Furthermore, the abstract supertype SymmetricBraiding denotes the cases where braidings are equivalent to crossings, i.e. braiding twice is an identity operation. This includes the Bosonic and Fermionic styles, for which we can uniquely define permutations.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.CU1Irrep","page":"Library","title":"TensorKitSectors.CU1Irrep","text":"struct CU1Irrep <: AbstractIrrep{CU‚ÇÅ}\nCU1Irrep(j, s = ifelse(j>zero(j), 2, 0))\nIrrep[CU‚ÇÅ](j, s = ifelse(j>zero(j), 2, 0))\n\nRepresents irreps of the group U‚ÇÅ  C (U‚ÇÅ and charge conjugation or reflection), which is also known as just O‚ÇÇ. \n\nFields\n\nj::HalfInt: the value of the U‚ÇÅ charge.\ns::Int: the representation of charge conjugation.\n\nThey can take values:\n\nif j == 0, s = 0 (trivial charge conjugation) or   s = 1 (non-trivial charge conjugation)\nif j > 0, s = 2 (two-dimensional representation)\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.CU‚ÇÅ","page":"Library","title":"TensorKitSectors.CU‚ÇÅ","text":"abstract type CU‚ÇÅ <: Group\n\nType to represent the group of U‚ÇÅ in combination with charge conjugation, i.e. the group generated by U‚ÇÅ and an additional element that acts as complex conjugation on U‚ÇÅ. This group is isomorphic to the orthogonal group O‚ÇÇ of real orthogonal 2√ó2 matrices, and can be seen as the semidirect product U‚ÇÅ ‚ãä ‚Ñ§‚ÇÇ. This is a compact non-Abelian group.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Cyclic","page":"Library","title":"TensorKitSectors.Cyclic","text":"abstract type Cyclic{N} <: AbelianGroup\n\nType to represent the cyclic group of order N, i.e. the multiplicative group of roots of unity of order N, which is a discrete abelian group. The cyclic group of order N is isomorphic to the additive group ‚Ñ§{N}, and we define the latter as a type alias const ‚Ñ§{N} = Cyclic{N}.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.DNIrrep","page":"Library","title":"TensorKitSectors.DNIrrep","text":"struct DNIrrep{N} <: AbstractIrrep{Dihedral{N}}\nDNIrrep{N}(n::Integer, isodd::Bool=false)\nIrrep[Dihedral{N}](n::Integer, isodd::Bool=false)\n\nRepresents irreps of the dihedral group D_N = Z_N  C (Z_N and charge conjugation or reflection).\n\nProperties\n\nj::Int: the value of the Z_N charge.\nisodd::Bool: the representation of charge conjugation.\n\nCombined these take the values +0 -0 1  (N - 1)  2 for odd N, and +0 -0 1  N  2 - 1 +(N2) -(N2) for even N, where the + (-) refer to the even (odd) one-dimensional irreps, while the others are two-dimensional.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Dihedral","page":"Library","title":"TensorKitSectors.Dihedral","text":"abstract type Dihedral{N} <: Group\n\nType to represent the dihedral group of order 2N, which is the symmetry group of a regular polygon with N sides, and is a discrete non-Abelian group. \n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.FermionNumber","page":"Library","title":"TensorKitSectors.FermionNumber","text":"const FermionNumber = U1Irrep ‚ä† FermionParity\nFermionNumber(a::Int)\n\nRepresents the fermion number as the direct product of a U‚ÇÅ irrep a and a fermion parity, with the restriction that the fermion parity is odd if and only if a is odd.\n\nSee also: U1Irrep, FermionParity\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.FermionParity","page":"Library","title":"TensorKitSectors.FermionParity","text":"struct FermionParity <: Sector\nFermionParity(isodd::Bool)\n\nRepresents sectors with fermion parity. The fermion parity is a ‚Ñ§‚ÇÇ quantum number that yields an additional sign when two odd fermions are exchanged, corresponding to a BraidingStyle that is Fermionic().\n\nFields\n\nisodd::Bool: indicates whether the fermion parity is odd (true) or even (false).\n\nSee also: FermionNumber, FermionSpin\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.FermionSpin","page":"Library","title":"TensorKitSectors.FermionSpin","text":"const FermionSpin = SU2Irrep ‚ä† FermionParity\nFermionSpin(j::Real)\n\nRepresents the fermion spin as the direct product of a SU‚ÇÇ irrep j and a fermion parity, with the restriction that the fermion parity is odd if 2 * j is odd.\n\nSee also: SU2Irrep, FermionParity\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Fermionic","page":"Library","title":"TensorKitSectors.Fermionic","text":"struct Fermionic <: SymmetricBraiding\n\nBraiding style with symmetric braiding and nontrivial (symmetric) twist. This is characterized by R^ab_c R^ba_c = 1 and theta_a = pm 1 for all sectors.\n\nSee also BraidingStyle.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.FibonacciAnyon","page":"Library","title":"TensorKitSectors.FibonacciAnyon","text":"struct FibonacciAnyon <: Sector\nFibonacciAnyon(s::Symbol)\n\nRepresents the anyons of the Fibonacci modular fusion category. It can take two values, corresponding to the trivial sector FibonacciAnyon(:I) and the non-trivial sector FibonacciAnyon(:œÑ) with fusion rules œÑ  œÑ = 1  œÑ.\n\nFields\n\nisunit::Bool: indicates whether the sector corresponds to the trivial anyon :I (true), or the non-trivial anyon :œÑ (false).\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.FusionStyle","page":"Library","title":"TensorKitSectors.FusionStyle","text":"abstract type FusionStyle\nFusionStyle(::Sector)\nFusionStyle(I::Type{<:Sector})\n\nTrait to describe the fusion behavior of sectors of type I, which can be either\n\nUniqueFusion: each fusion a ‚äó b has exactly one output c.\nSimpleFusion: fusing a ‚äó b can lead to multiple values c, but each appears at most once.\nGenericFusion: fusing a ‚äó b can lead to multiple values c that could appear multiple times.\n\nThere is an abstract supertype MultipleFusion of which both SimpleFusion and GenericFusion are subtypes. Furthermore, there is a type alias MultiplicityFreeFusion for those fusion types which do not require muliplicity labels.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.GenericFusion","page":"Library","title":"TensorKitSectors.GenericFusion","text":"struct GenericFusion <: MultipleFusion\n\nFusion style with potentially multiple outputs c and nontrivial multiplicities. Here N_c^ab can exceed 1, and multiplicity labels are required.\n\nSee also FusionStyle.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.GenericUnit","page":"Library","title":"TensorKitSectors.GenericUnit","text":"struct GenericUnit <: UnitStyle\n\nUnit style for multifusion categories with multiple unit objects (semisimple unit). Requires implementation of allunits(::Type{I}), leftunit(a), and rightunit(a).\n\nSee also UnitStyle.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Group","page":"Library","title":"TensorKitSectors.Group","text":"abstract type Group\n\nAbstract supertype for representing different types of groups. Groups can be used to define Sector subtypes, either via their irreducible representations, or via their group elements, and typically appear as type parameter. As such, they are not meant to be instantiated and are defined as abstract types.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.HasBraiding","page":"Library","title":"TensorKitSectors.HasBraiding","text":"abstract type HasBraiding <: BraidingStyle\n\nSupertype for all braiding styles where an Rsymbol is defined. This includes all current BraidingStyles except NoBraiding.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.IsingAnyon","page":"Library","title":"TensorKitSectors.IsingAnyon","text":"struct IsingAnyon <: Sector\nIsingAnyon(s::Symbol)\n\nRepresents the anyons of the Ising modular fusion category. It can take three values, corresponding to the trivial sector IsingAnyon(:I) and the non-trivial sectors IsingAnyon(:œÉ) and IsingAnyon(:œà), with fusion rules œà  œà = 1, œÉ  œà = œÉ, and œÉ  œÉ = 1  œà.\n\nFields\n\ns::Symbol: the label of the represented anyon, which can be :I, :œÉ, or :œà.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.IsingBimodule","page":"Library","title":"TensorKitSectors.IsingBimodule","text":"struct IsingBimodule <: Sector\n\nType to represent the simple objects in the Ising category reinterpreted as a bimodule category composed of two copies of the category ùíû = ùíü = Irrep[‚Ñ§‚ÇÇ], the two simple objects of which can be identified with the Ising anyons {I, œà}, and the bimodule categories ‚Ñ≥ = ‚Ñ≥·µí·µñ = Vec, with a single simple object that can be identified with the Ising anyon œÉ. This constitutes the easiest example of a multifusion category and is implemented here for testing purposes and to illustrate how to implement such categories in TensorKitSectors.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.LargeZNIrrep","page":"Library","title":"TensorKitSectors.LargeZNIrrep","text":"struct LargeZNIrrep{N} <: AbstractIrrep{‚Ñ§{N}}\nLargeZNIrrep{N}(n::Integer)\nIrrep[‚Ñ§{N}](n::Integer)\n\nRepresents irreps of the group ‚Ñ§_N for some value of N, which is typically larger than 128. For smaller values of N, the ZNIrrep sector type should be used instead. An arbitrary Integer n can be provided to the constructor, but only the value mod(n, N) is relevant.\n\nThe constructor Irrep[‚Ñ§{N}] should be preferred, as it will automatically select the most efficient storage type for a given value of N.\n\nSee also charge and modulus to extract the relevant data.\n\nFields\n\nn::UInt: the integer label of the irrep, modulo N.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.MultipleFusion","page":"Library","title":"TensorKitSectors.MultipleFusion","text":"abstract type MultipleFusion <: FusionStyle\n\nFusion styles that allow more than one fusion output for a ‚äó b.\n\nSee also SimpleFusion, GenericFusion and FusionStyle.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.NoBraiding","page":"Library","title":"TensorKitSectors.NoBraiding","text":"struct NoBraiding <: BraidingStyle\n\nBraiding style for categories without a braiding structure. Except for braiding with the unit sector, only planar diagrams are meaningful; Rsymbol is undefined.\n\nSee also BraidingStyle.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.PlanarTrivial","page":"Library","title":"TensorKitSectors.PlanarTrivial","text":"struct PlanarTrivial <: Sector\nPlanarTrivial()\n\nRepresents a trivial anyon sector, i.e. a trivial sector without braiding. This is mostly useful for testing.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.ProductGroup","page":"Library","title":"TensorKitSectors.ProductGroup","text":"abstract type ProductGroup{T <: Tuple{Vararg{Group}}} <: Group\n\nType to represent the direct product of a tuple of groups. This is typically constructed via the √ó operator.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.ProductSector","page":"Library","title":"TensorKitSectors.ProductSector","text":"struct ProductSector{T <: SectorTuple}\nProductSector((s‚ÇÅ, s‚ÇÇ, ...))\n\nRepresents the Deligne tensor product of sectors. The type parameter T is a tuple of the component sectors. The recommended way to construct a ProductSector is using the deligneproduct (‚ä†) operator on the components.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.SU","page":"Library","title":"TensorKitSectors.SU","text":"abstract type SU{N} <: Group\n\nType to represent the special unitary group SU(N), which is a compact non-Abelian Lie group.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.SU2Irrep","page":"Library","title":"TensorKitSectors.SU2Irrep","text":"struct SU2Irrep <: AbstractIrrep{SU‚ÇÇ}\nSU2Irrep(j::Real)\nIrrep[SU‚ÇÇ](j::Real)\n\nRepresents irreps of the group SU‚ÇÇ. The irrep is labeled by a half integer j which can be entered as an arbitrary Real, but is stored as a HalfInt from the HalfIntegers.jl package.\n\nFields\n\nj::HalfInt: the label of the irrep, which can be any non-negative half integer.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Sector","page":"Library","title":"TensorKitSectors.Sector","text":"abstract type Sector\n\nAbstract type for representing the (isomorphism classes of) simple objects in (unitary and pivotal) (pre-)fusion categories, e.g. the irreducible representations of a finite or compact group. Subtypes I <: Sector as the set of labels of a GradedSpace.\n\nEvery new I <: Sector should implement the following methods:\n\nunit(::Type{I}): unit element of I. If there are multiple, implement allunits(::Type{I})   instead.\ndual(a::I): aÃÖ, conjugate or dual label of a\n‚äó(a::I, b::I): iterable with unique fusion outputs of a  b   (i.e. don't repeat in case of multiplicities)\nNsymbol(a::I, b::I, c::I): number of times c appears in a ‚äó b, i.e. the   multiplicity\nFusionStyle(::Type{I}): UniqueFusion(), SimpleFusion() or   GenericFusion()\nBraidingStyle(::Type{I}): Bosonic(), Fermionic(), Anyonic(), ...\nFsymbol(a::I, b::I, c::I, d::I, e::I, f::I): F-symbol: scalar (in case of   UniqueFusion/SimpleFusion) or rank-4 array (in case of GenericFusion)\nRsymbol(a::I, b::I, c::I): R-symbol: scalar (in case of   UniqueFusion/SimpleFusion) or matrix (in case of GenericFusion)\nisless(a::I, b::I): defines a canonical ordering of sectors\nhash(a::I): hash function for sectors\n\nand optionally\n\ndim(a::I): quantum dimension of sector a\nfrobenius_schur_indicator(a::I): Frobenius-Schur indicator of a (1, 0, -1)\nfrobenius_schur_phase(a::I): Frobenius-Schur phase of a (¬±1)\nsectorscalartype(::Type{I}): scalar type of F- and R-symbols\nBsymbol(a::I, b::I, c::I): B-symbol: scalar (in case of   UniqueFusion/SimpleFusion) or matrix (in case of GenericFusion)\ntwist(a::I) -> twist of sector a\n\nFurthermore, iterate and Base.IteratorSize should be made to work for the singleton type SectorValues{I}.\n\nTo help with the implementation of ‚äó(a::I, b::I) as an iterator, the provided struct type SectorProductIterator{I} can be used, which stores a and b and requires the implementation of Base.iterate(::SectorProductIterator{I}, state...).\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.SectorProductIterator","page":"Library","title":"TensorKitSectors.SectorProductIterator","text":"struct SectorProductIterator{I <: Sector}\nSectorProductIterator(a::I, b::I) where {I <: Sector}\n\nCustom iterator to represent the (unique) fusion outputs of a  b.\n\nCustom sectors that aim to use this have to provide the following functionality:\n\nBase.iterate(::SectorProductIterator{I}, state...) where {I <: Sector}: iterate over   the fusion outputs of a ‚äó b\n\nIf desired and it is possible to easily compute the number of unique fusion outputs, it is also possible to define Base.IteratorSize(::Type{SectorProductIterator{I}}) = Base.HasLength(), in which case Base.length(::SectorProductIterator{I}) has to be implemented.\n\nSee also ‚äó.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.SectorValues","page":"Library","title":"TensorKitSectors.SectorValues","text":"struct SectorValues{I <: Sector}\n\nSingleton type to represent an iterator over the possible values of type I, whose instance is obtained as values(I). For a new I::Sector, the following should be defined\n\nBase.iterate(::SectorValues{I}[, state]): iterate over the values\nBase.IteratorSize(::Type{SectorValues{I}}): HasLength(), SizeUnknown()   or IsInfinite() depending on whether the number of values of type I is finite   (and sufficiently small) or infinite; for a large number of values, SizeUnknown() is   recommended because this will trigger the use of GenericGradedSpace.\n\nIf IteratorSize(I) == HasLength(), also the following must be implemented:\n\nBase.length(::SectorValues{I}): the number of different values\nBase.getindex(::SectorValues{I}, i::Int): a mapping between an index i and an   instance of I. A fallback implementation exists that returns the ith value   of the SectorValues iterator.\nfindindex(::SectorValues{I}, c::I): reverse mapping between a value c::I and an   index i::Integer ‚àà 1:length(values(I)). A fallback implementation exists that   linearly searches through the SectorValues iterator.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.SimpleFusion","page":"Library","title":"TensorKitSectors.SimpleFusion","text":"struct SimpleFusion <: MultipleFusion\n\nFusion style where multiple outputs c can appear in a ‚äó b, but each appears at most once. As a result, N_c^ab  1 and no multiplicity labels are needed.\n\nSee also FusionStyle.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.SimpleUnit","page":"Library","title":"TensorKitSectors.SimpleUnit","text":"struct SimpleUnit <: UnitStyle\n\nUnit style for fusion categories with a unique unit (identity) object. The unit satisfies mathbb1  a  a  a  mathbb1 for all sectors.\n\nSee also UnitStyle.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.SymmetricBraiding","page":"Library","title":"TensorKitSectors.SymmetricBraiding","text":"abstract type SymmetricBraiding <: HasBraiding\n\nSupertype for braiding styles with symmetric braiding, where braiding twice is the identity operation. Subtypes include Bosonic (trivial twist) and Fermionic (nontrivial twist ¬±1). Supports permutation group statistics.\n\nSee also BraidingStyle.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.TimeReversed","page":"Library","title":"TensorKitSectors.TimeReversed","text":"struct TimeReversed{I <: Sector}\nTimeReversed(a::I) where {I <: Sector}\n\nRepresents the time-reversed version of the sector I, i.e. the sector with the same fusion rules and F-symbols, but with the inverse braiding.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.Trivial","page":"Library","title":"TensorKitSectors.Trivial","text":"struct Trivial <: Sector\nTrivial()\n\nSingleton type to represent the trivial sector, i.e. the trivial representation of the trivial group. This is equivalent to Rep[‚Ñ§‚ÇÅ], or the unit object of the category Vect of ordinary vector spaces.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.U1Irrep","page":"Library","title":"TensorKitSectors.U1Irrep","text":"struct U1Irrep <: AbstractIrrep{U‚ÇÅ}\nU1Irrep(charge::Real)\nIrrep[U‚ÇÅ](charge::Real)\n\nRepresents irreps of the group U‚ÇÅ. The irrep is labelled by a charge, which should be an integer for a linear representation. However, it is often useful to allow half integers to represent irreps of U‚ÇÅ subgroups of SU‚ÇÇ, such as the S^z of spin-1/2 system. Hence, the charge is stored as a HalfInt from the package HalfIntegers.jl, but can be entered as arbitrary Real. The sequence of the charges is: 0, 1/2, -1/2, 1, -1, ...\n\nFields\n\ncharge::HalfInt: the label of the irrep, which can be any half integer.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.UniqueFusion","page":"Library","title":"TensorKitSectors.UniqueFusion","text":"struct UniqueFusion <: FusionStyle\n\nFusion style where every product a ‚äó b has exactly one output c. As a result, N_c^ab  1 and no multiplicity labels are needed.\n\nSee also FusionStyle.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.UnitStyle","page":"Library","title":"TensorKitSectors.UnitStyle","text":"abstract type UnitStyle\nUnitStyle(::Sector)\nUnitStyle(I::Type{<:Sector})\n\nTrait to describe the semisimplicity of the unit sector of type I. This can be either\n\nSimpleUnit: the unit is simple (e.g. fusion categories).\nGenericUnit: the unit is semisimple (e.g. multifusion categories).\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.U‚ÇÅ","page":"Library","title":"TensorKitSectors.U‚ÇÅ","text":"abstract type U‚ÇÅ <: AbelianGroup\n\nType to represent the group U(1) of complex numbers of unit modulus, which is a compact Abelian Lie group.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.ZNElement","page":"Library","title":"TensorKitSectors.ZNElement","text":"struct ZNElement{N, p} <: AbstractGroupElement{‚Ñ§{N}}\nZNElement{N, p}(n::Integer)\nGroupElement[‚Ñ§{N}, p](n::Integer)\n\nRepresents an element of the group ‚Ñ§_N for some value of N < 64. (We need 2 * (N - 1) <= 127 in order for a ‚äó b to work correctly.) For N equals 2, 3 or 4, ‚Ñ§{N} can be replaced by ‚Ñ§‚ÇÇ, ‚Ñ§‚ÇÉ, ‚Ñ§‚ÇÑ. An arbitrary Integer n can be provided to the constructor, but only the value mod(n, N) is relevant. The second type parameter p should also be specified as an integer 0 <= p < N and specifies the 3-cocycle, which is then being given by\n\ncocycle(a, b, c) = cispi(2 * p * a.n * (b.n + c.n - mod(b.n + c.n, N)) / N))\n\nIf p is not specified, it defaults to 0, i.e. the trivial cocycle.\n\nFields\n\nn::Int8: the integer label of the element, modulo N.\n\n\n\n\n\n","category":"type"},{"location":"lib/#TensorKitSectors.ZNIrrep","page":"Library","title":"TensorKitSectors.ZNIrrep","text":"struct ZNIrrep{N} <: AbstractIrrep{‚Ñ§{N}}\nZNIrrep{N}(n::Integer)\nIrrep[‚Ñ§{N}](n::Integer)\n\nRepresents irreps of the group ‚Ñ§_N for some value of N. For N equals 2, 3 or 4, ‚Ñ§{N} can be replaced by ‚Ñ§‚ÇÇ, ‚Ñ§‚ÇÉ, and ‚Ñ§‚ÇÑ. An arbitrary Integer n can be provided to the constructor, but only the value mod(n, N) is relevant.\n\nThe type of the stored integer (UInt8) requires N ‚â§ 128. Larger values of N should use the LargeZNIrrep instead. The constructor Irrep[‚Ñ§{N}] should be preferred, as it will automatically select the most efficient storage type for a given value of N.\n\nSee also charge and modulus to extract the relevant data.\n\nFields\n\nn::UInt8: the integer label of the irrep, modulo N.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Base.isreal-Tuple{Type{<:Sector}}","page":"Library","title":"Base.isreal","text":"isreal(::Type{<:Sector}) -> Bool\n\nReturn whether the topological data (Fsymbol, Rsymbol) of the sector is real or not (in which case it is complex).\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.:√ó-Tuple{Vararg{Type{<:Group}}}","page":"Library","title":"TensorKitSectors.:√ó","text":"√ó(G::Vararg{Type{<:Group}}) -> ProductGroup{Tuple{G...}}\ntimes(G::Vararg{Type{<:Group}}) -> ProductGroup{Tuple{G...}}\n\nConstruct the direct product of a (list of) groups.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.:‚äó","page":"Library","title":"TensorKitSectors.:‚äó","text":"‚äó(a::I, b::I...) where {I <: Sector}\notimes(a::I, b::I...) where {I <: Sector}\n\nReturn an iterable of elements of c::I that appear in the fusion product a ‚äó b. Each sector c should appear at most once in this iteration, even if the multiplicity N_c^ab  1. The actual multiplicities are accessed separately through Nsymbol.\n\nThe return type is typically SectorProductIterator{I} which provides a type-stable iterable that supports pretty-printing, but could also be any custom iterable.\n\nSee also FusionStyle for the trait associated to the fusion behavior of a given sector type.\n\n\n\n\n\n","category":"function"},{"location":"lib/#TensorKitSectors.:‚ä†-Tuple{Sector, Sector}","page":"Library","title":"TensorKitSectors.:‚ä†","text":"‚ä†(s‚ÇÅ::Sector, s‚ÇÇ::Sector)\ndeligneproduct(s‚ÇÅ::Sector, s‚ÇÇ::Sector)\n\nGiven two sectors s‚ÇÅ and s‚ÇÇ, which label an isomorphism class of simple objects in a fusion category C‚ÇÅ and C‚ÇÇ, s1 ‚ä† s2 (obtained as \\boxtimes+TAB) labels the isomorphism class of simple objects in the Deligne tensor product category C‚ÇÅ  C‚ÇÇ.\n\nThe Deligne tensor product also works in the type domain and for spaces and tensors. For group representations, we have Irrep[G‚ÇÅ] ‚ä† Irrep[G‚ÇÇ] == Irrep[G‚ÇÅ √ó G‚ÇÇ].\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.Asymbol-Union{Tuple{I}, Tuple{I, I, I}} where I<:Sector","page":"Library","title":"TensorKitSectors.Asymbol","text":"Asymbol(a::I, b::I, c::I) where {I <: Sector}\n\nReturn the value of A^ab_c which appears in transforming a splitting vertex into a fusion vertex using the transformation\n\na -<-Œº-<- c                                                    b -<-ŒΩ-<- dual(a)\n     ‚à®       -> ‚àö(dim(c) / dim(b)) * Asymbol(a, b, c)[Œº, ŒΩ]         ‚àß\n     b                                                              c\n\nIf FusionStyle(I) is UniqueFusion() or SimpleFusion(), the A-symbol is a number. Otherwise it is a square matrix with row and column size Nsymbol(a, b, c) == Nsymbol(dual(a), c, b).\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.Bsymbol-Union{Tuple{I}, Tuple{I, I, I}} where I<:Sector","page":"Library","title":"TensorKitSectors.Bsymbol","text":"Bsymbol(a::I, b::I, c::I) where {I <: Sector}\n\nReturn the value of B^ab_c which appears in transforming a splitting vertex into a fusion vertex using the transformation\n\na -<-Œº-<- c                                                    a -<-ŒΩ-<- c\n     ‚à®       -> ‚àö(dim(c) / dim(a)) * Bsymbol(a, b, c)[Œº, ŒΩ]         ‚àß\n     b                                                            dual(b)\n\nIf FusionStyle(I) is UniqueFusion() or SimpleFusion(), the B-symbol is a number. Otherwise it is a square matrix with row and column size Nsymbol(a, b, c) == Nsymbol(c, dual(b), a).\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.Fsymbol","page":"Library","title":"TensorKitSectors.Fsymbol","text":"Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I <: Sector}\n\nReturn the F-symbol F^abc_d that associates the two different fusion orders of sectors a, b and c into an ouput sector d, using either an intermediate sector a  b  e or b  c  f:\n\na-<-Œº-<-e-<-ŒΩ-<-d                                     a-<-Œª-<-d\n    ‚à®       ‚à®       -> Fsymbol(a,b,c,d,e,f)[Œº,ŒΩ,Œ∫,Œª]      ‚à®\n    b       c                                             f\n                                                          v\n                                                      b-<-Œ∫\n                                                          ‚à®\n                                                          c\n\nIf FusionStyle(I) is UniqueFusion or SimpleFusion, the F-symbol is a number. Otherwise it is a rank 4 array of size (Nsymbol(a, b, e), Nsymbol(e, c, d), Nsymbol(b, c, f), Nsymbol(a, f, d)).\n\n\n\n\n\n","category":"function"},{"location":"lib/#TensorKitSectors.Nsymbol","page":"Library","title":"TensorKitSectors.Nsymbol","text":"Nsymbol(a::I, b::I, c::I) where {I <: Sector} -> Integer\n\nThe fusion multiplicity N_c^ab, indicating how many times sector c appears in the fusion product a ‚äó b.\n\nThe return type depends on the [FusionStyle](@ref), where UniqueFusion and SimpleFusion return Bool values, while [GenericFusion] returns Int.\n\nSee also ‚äó to obtain the set of sectors c that appear in a ‚äó b.\n\n\n\n\n\n","category":"function"},{"location":"lib/#TensorKitSectors.Rsymbol","page":"Library","title":"TensorKitSectors.Rsymbol","text":"Rsymbol(a::I, b::I, c::I) where {I <: Sector}\n\nReturns the R-symbol R^ab_c that maps between c  a  b and c  b  a as in\n\na -<-Œº-<- c                                 b -<-ŒΩ-<- c\n     ‚à®        -> Rsymbol(a, b, c)[Œº, ŒΩ]          v\n     b                                           a\n\nIf FusionStyle(I) is UniqueFusion() or SimpleFusion(), the R-symbol is a number. Otherwise it is a square matrix with row and column size Nsymbol(a, b, c) == Nsymbol(b, a, c).\n\n\n\n\n\n","category":"function"},{"location":"lib/#TensorKitSectors.allunits-Union{Tuple{Type{I}}, Tuple{I}} where I<:Sector","page":"Library","title":"TensorKitSectors.allunits","text":"allunits(I::Type{<:Sector}) -> Tuple{I}\n\nReturn a tuple with all units of the sector type I. For fusion categories, this will contain only one element.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.braidingscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I<:Sector","page":"Library","title":"TensorKitSectors.braidingscalartype","text":"braidingscalartype(I::Type{<:Sector}) -> Type{<:Number}\n\nReturn the scalar type of the topological data associated to braiding of the sector I. In particular, this is the scalar type of Rsymbol.\n\nSee also fusionscalartype and sectorscalartype.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.charge-Tuple{U1Irrep}","page":"Library","title":"TensorKitSectors.charge","text":"charge(c::U1Irrep) -> HalfInt\n\nThe charge label of the irrep c.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.charge-Tuple{Union{LargeZNIrrep{N}, ZNIrrep{N}} where N}","page":"Library","title":"TensorKitSectors.charge","text":"charge(c::ZNIrrep) -> Int\n\nThe charge label of the irrep c.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.dim-Tuple{Sector}","page":"Library","title":"TensorKitSectors.dim","text":"dim(a::Sector)\n\nReturn the (quantum) dimension of the sector a.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.dimscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I<:Sector","page":"Library","title":"TensorKitSectors.dimscalartype","text":"dimscalartype(::Type{<:Sector}) -> Type{<:Number}\n\nReturn the scalar type of the quantum dimensions associated to sectors of type I. In particular, this is the scalar type of dim.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.dual-Tuple{Sector}","page":"Library","title":"TensorKitSectors.dual","text":"dual(a::Sector) -> Sector\n\nReturn the dual label of a, i.e. the unique label aÃÑ = dual(a) such that  Nsymbol(a, aÃÑ, leftunit(a)) == 1 and Nsymbol(aÃÑ, a, rightunit(a)) == 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.findindex-Union{Tuple{I}, Tuple{SectorValues{I}, I}} where I<:Sector","page":"Library","title":"TensorKitSectors.findindex","text":"findindex(v::SectorValues{I}, c::I)\n\nReverse mapping between a value c::I and an index i::Integer ‚àà 1:length(values(I)).\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.frobenius_schur_indicator-Tuple{Sector}","page":"Library","title":"TensorKitSectors.frobenius_schur_indicator","text":"frobenius_schur_indicator(a::Sector)\n\nReturn the Frobenius-Schur indicator of a sector ŒΩ‚Çê  1 0 -1, which distinguishes between real, complex and quaternionic representations.\n\nSee also frobenius_schur_phase for the category-theoretic version that appears in the context of line bending.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.frobenius_schur_phase-Tuple{Sector}","page":"Library","title":"TensorKitSectors.frobenius_schur_phase","text":"frobenius_schur_phase(a::Sector)\n\nReturn the Frobenius-Schur phase Œ∫‚Çê of a sector a, which is a complex phase that appears in the context of bending lines and is obtained from F^a aÃÖ a_a. When a == dual(a), it is restricted to Œ∫‚Çê  1 -1 and coincides with the group-theoretic version frobenius_schur_indicator. When a != dual(a), the value of Œ∫‚Çê can be gauged to be 1, though is not required to be.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.fusionscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I<:Sector","page":"Library","title":"TensorKitSectors.fusionscalartype","text":"fusionscalartype(I::Type{<:Sector}) -> Type{<:Number}\n\nReturn the scalar type of the topological data associated to fusion of the sector I. In particular, this is the scalar type of Fsymbol.\n\nSee also braidingscalartype and sectorscalartype.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.fusiontensor-Union{Tuple{I}, Tuple{I, I, I}} where I<:Sector","page":"Library","title":"TensorKitSectors.fusiontensor","text":"fusiontensor(a::I, b::I, c::I) where {I <: Sector} -> AbstractArray{T, 4}\n\nReturn the fusion tensor for the fusion a ‚äó b -> c. The dimensions of the returned array are (dim(a), dim(b), dim(c), Nsymbol(a, b, c)). The components of the fusion tensor are simply the Clebsch-Gordan coefficients, describing the unitary basis change from the tensor product of irreps a and b to the coupled irrep c.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.hexagon_equation-Union{Tuple{I}, Tuple{I, I, I}} where I<:Sector","page":"Library","title":"TensorKitSectors.hexagon_equation","text":"hexagon_equation(a::I, b::I, c::I; kwargs...) where {I <: Sector} -> Bool\n\nCheck whether the hexagon equation holds for braiding the sector a around the fusion product of b and c along the two different paths.\n\nIf kwargs are provided, they are forwarded to isapprox when comparing the two sides of the hexagon equation.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.invsqrtdim-Tuple{Sector}","page":"Library","title":"TensorKitSectors.invsqrtdim","text":"invsqrtdim(a::Sector)\n\nReturn the inverse square root of the (quantum) dimension of sector a.\n\nThis is a performance specialization that avoids computing inv(sqrt(1)) for sectors with  UniqueFusion, preserving the number type (returning 1::Int instead of 1.0::Float64). For other sectors, it is equivalent to inv(sqrt(dim(a))).\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.isunit-Tuple{Sector}","page":"Library","title":"TensorKitSectors.isunit","text":"isunit(a::Sector) -> Bool\n\nReturn whether sector a is a unit element.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.leftunit-Tuple{Sector}","page":"Library","title":"TensorKitSectors.leftunit","text":"leftunit(a::Sector) -> Sector\n\nReturn the left unit element corresponding to a; this is necessary for multifusion categories, where the unit may not be unique. See also rightunit and unit.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.modulus-Tuple{Union{LargeZNIrrep{N}, ZNIrrep{N}} where N}","page":"Library","title":"TensorKitSectors.modulus","text":"modulus(c::ZNIrrep{N}) -> N\nmodulus(::Type{<:ZNIrrep{N}}) -> N\n\nThe order of the cyclic group, or the modulus of the charge labels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.pentagon_equation-Union{Tuple{I}, NTuple{4, I}} where I<:Sector","page":"Library","title":"TensorKitSectors.pentagon_equation","text":"pentagon_equation(a::I, b::I, c::I, d::I; kwargs...) where {I <: Sector} -> Bool\n\nCheck whether the pentagon equation holds for fusing the sectors a, b, c and d to each of their sectors along the two different fusion paths.\n\nIf kwargs are provided, they are forwarded to isapprox when comparing the two sides of the pentagon equation.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.precompile_sector-Union{Tuple{Type{I}}, Tuple{I}} where I<:Sector","page":"Library","title":"TensorKitSectors.precompile_sector","text":"precompile_sector(I::Type{<:Sector})\n\nPrecompile common methods for the given sector type.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.rightunit-Tuple{Sector}","page":"Library","title":"TensorKitSectors.rightunit","text":"rightunit(a::Sector) -> Sector\n\nReturn the right unit element corresponding to a; this is necessary for multifusion categories, where the unit may not be unique. See also leftunit and unit.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.sectorscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I<:Sector","page":"Library","title":"TensorKitSectors.sectorscalartype","text":"sectorscalartype(I::Type{<:Sector}) -> Type{<:Number}\n\nReturn the scalar type of the topological data of the sector I. In particular, this is a combination of the scalar type of both the Fsymbol and Rsymbol, and determines the scalar type of the fusiontensor whenever it is defined.\n\nSee also fusionscalartype and braidingscalartype.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.sqrtdim-Tuple{Sector}","page":"Library","title":"TensorKitSectors.sqrtdim","text":"sqrtdim(a::Sector)\n\nReturn the square root of the (quantum) dimension of sector a.\n\nThis is a performance specialization that avoids computing sqrt(1) for sectors with  UniqueFusion, preserving the number type (returning 1::Int instead of 1.0::Float64). For other sectors, it is equivalent to sqrt(dim(a)).\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.twist-Tuple{Sector}","page":"Library","title":"TensorKitSectors.twist","text":"twist(a::Sector)\n\nReturn the twist of a sector a.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.type_repr-Tuple{Type}","page":"Library","title":"TensorKitSectors.type_repr","text":"type_repr(T::Type)\n\nReturn a string representation of the type T, which is used to modify the default way in which Sector subtypes are displayed in other objects that depend on them.\n\n\n\n\n\n","category":"method"},{"location":"lib/#TensorKitSectors.unit-Tuple{Sector}","page":"Library","title":"TensorKitSectors.unit","text":"unit(::Sector) -> Sector\nunit(::Type{<:Sector}) -> Sector\n\nReturn the unit element of this type of sector, provided it is unique.\n\n\n\n\n\n","category":"method"},{"location":"sectors/abelian/trivial/#Trivial-Sector","page":"Trivial","title":"Trivial Sector","text":"","category":"section"},{"location":"sectors/abelian/trivial/#Trivial","page":"Trivial","title":"Trivial","text":"","category":"section"},{"location":"sectors/abelian/trivial/#Type-Definition","page":"Trivial","title":"Type Definition","text":"","category":"section"},{"location":"sectors/abelian/trivial/#Construction","page":"Trivial","title":"Construction","text":"","category":"section"},{"location":"sectors/abelian/trivial/#Labels","page":"Trivial","title":"Labels","text":"","category":"section"},{"location":"sectors/abelian/trivial/#Fusion-Rules","page":"Trivial","title":"Fusion Rules","text":"","category":"section"},{"location":"sectors/abelian/trivial/#Quantum-Dimensions","page":"Trivial","title":"Quantum Dimensions","text":"","category":"section"},{"location":"sectors/abelian/trivial/#Topological-Data","page":"Trivial","title":"Topological Data","text":"","category":"section"},{"location":"interface/traits/#Traits-and-Styles","page":"Traits and Styles","title":"Traits and Styles","text":"Traits define compile-time properties that can be assumed about a sector type. They control behavior and enable optimizations.","category":"section"},{"location":"interface/traits/#FusionStyle","page":"Traits and Styles","title":"FusionStyle","text":"The FusionStyle trait indicates how many outputs to expect when fusing two sectors.\n\nThis enables various optimizations for different cases. Firstly, since the shape (size of the arrays) of the topological data is determined by combinations of the Nsymbol, for UniqueFusion and SimpleFusion we can use scalar quantities instead of arrays. Secondly, in the UniqueFusion case, there is only a single channel for a otimes b otimes c otimes ldots, avoiding the need to iterate through all options.\n\nIt is additionally possible to combine fusion styles through the & operator, which returns the style with the least assumptions. For example:\n\njulia> UniqueFusion() & SimpleFusion()\nSimpleFusion()\n\njulia> GenericFusion() & UniqueFusion()\nGenericFusion()\n\nFinally, some predefined combinations that appear often have dedicated names:","category":"section"},{"location":"interface/traits/#BraidingStyle","page":"Traits and Styles","title":"BraidingStyle","text":"The BraidingStyle describes whether and how exchange of sectors is defined. It determines how TensorKit interprets Rsymbol and twist.\n\nAdditionally, this dictates whether or not permutations are sufficient to specify generic exchanges, or if a full braid group representation is needed.\n\nIt is also possible to combine braiding styles through the & operator, which returns the style with the least assumptions. For example:\n\njulia> Bosonic() & Fermionic()\nFermionic()\n\njulia> Fermionic() & Anyonic()\nAnyonic()\n\njulia> Bosonic() & NoBraiding()\nNoBraiding()\n\nFinally, some predefined combinations that appear often have dedicated names:","category":"section"},{"location":"interface/traits/#UnitStyle","page":"Traits and Styles","title":"UnitStyle","text":"The UnitStyle tells whether there is a single identity label or multiple units. By default, it is derived from length(allunits(I)).\n\nWhenever the style is SimpleUnit, a unique value of unit can be defined and there is no distinction between leftunit and rightunit. For GenericUnit, this is no longer the case and special care has to be taken to use the correct unit for various fusion diagrams.","category":"section"},{"location":"interface/traits/#TensorKitSectors.FusionStyle-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.FusionStyle","text":"abstract type FusionStyle\nFusionStyle(::Sector)\nFusionStyle(I::Type{<:Sector})\n\nTrait to describe the fusion behavior of sectors of type I, which can be either\n\nUniqueFusion: each fusion a ‚äó b has exactly one output c.\nSimpleFusion: fusing a ‚äó b can lead to multiple values c, but each appears at most once.\nGenericFusion: fusing a ‚äó b can lead to multiple values c that could appear multiple times.\n\nThere is an abstract supertype MultipleFusion of which both SimpleFusion and GenericFusion are subtypes. Furthermore, there is a type alias MultiplicityFreeFusion for those fusion types which do not require muliplicity labels.\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.UniqueFusion-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.UniqueFusion","text":"struct UniqueFusion <: FusionStyle\n\nFusion style where every product a ‚äó b has exactly one output c. As a result, N_c^ab  1 and no multiplicity labels are needed.\n\nSee also FusionStyle.\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.SimpleFusion-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.SimpleFusion","text":"struct SimpleFusion <: MultipleFusion\n\nFusion style where multiple outputs c can appear in a ‚äó b, but each appears at most once. As a result, N_c^ab  1 and no multiplicity labels are needed.\n\nSee also FusionStyle.\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.GenericFusion-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.GenericFusion","text":"struct GenericFusion <: MultipleFusion\n\nFusion style with potentially multiple outputs c and nontrivial multiplicities. Here N_c^ab can exceed 1, and multiplicity labels are required.\n\nSee also FusionStyle.\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.MultipleFusion-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.MultipleFusion","text":"abstract type MultipleFusion <: FusionStyle\n\nFusion styles that allow more than one fusion output for a ‚äó b.\n\nSee also SimpleFusion, GenericFusion and FusionStyle.\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.MultiplicityFreeFusion-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.MultiplicityFreeFusion","text":"const MultiplicityFreeFusion = Union{UniqueFusion, SimpleFusion}\n\nConvenience alias for fusion styles that can assume Nsymbol(a, b, c)::Bool, and therefore never require multiplicity labels.\n\nSee also UniqueFusion, SimpleFusion and FusionStyle.\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.BraidingStyle-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.BraidingStyle","text":"abstract type BraidingStyle\nBraidingStyle(::Sector) -> ::BraidingStyle\nBraidingStyle(I::Type{<:Sector}) -> ::BraidingStyle\n\nTrait to describe the braiding behavior of sectors of type I, which can be either\n\nNoBraiding: no braiding structure defined.\nBosonic: symmetric braiding structure with a trivial twist.\nFermionic: symmetric braiding structure with a non-trivial twist that squares to identity.\nAnyonic: general braiding structure and arbitrary twists.\n\nThere is an abstract supertype HasBraiding that includes all styles that define Rsymbol (everything but NoBraiding). Furthermore, the abstract supertype SymmetricBraiding denotes the cases where braidings are equivalent to crossings, i.e. braiding twice is an identity operation. This includes the Bosonic and Fermionic styles, for which we can uniquely define permutations.\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.NoBraiding-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.NoBraiding","text":"struct NoBraiding <: BraidingStyle\n\nBraiding style for categories without a braiding structure. Except for braiding with the unit sector, only planar diagrams are meaningful; Rsymbol is undefined.\n\nSee also BraidingStyle.\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.Bosonic-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.Bosonic","text":"struct Bosonic <: SymmetricBraiding\n\nBraiding style with symmetric braiding and trivial twist. This is characterized by R^ab_c R^ba_c = 1 and theta_a = 1 for all sectors.\n\nSee also BraidingStyle.\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.Fermionic-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.Fermionic","text":"struct Fermionic <: SymmetricBraiding\n\nBraiding style with symmetric braiding and nontrivial (symmetric) twist. This is characterized by R^ab_c R^ba_c = 1 and theta_a = pm 1 for all sectors.\n\nSee also BraidingStyle.\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.Anyonic-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.Anyonic","text":"struct Anyonic <: HasBraiding\n\nBraiding style with general (non-symmetric) braiding and arbitrary twists. Characterized by nontrivial braid group representations where R^ab_c R^ba_c  1 in general.\n\nSee also BraidingStyle.\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.HasBraiding-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.HasBraiding","text":"abstract type HasBraiding <: BraidingStyle\n\nSupertype for all braiding styles where an Rsymbol is defined. This includes all current BraidingStyles except NoBraiding.\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.SymmetricBraiding-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.SymmetricBraiding","text":"abstract type SymmetricBraiding <: HasBraiding\n\nSupertype for braiding styles with symmetric braiding, where braiding twice is the identity operation. Subtypes include Bosonic (trivial twist) and Fermionic (nontrivial twist ¬±1). Supports permutation group statistics.\n\nSee also BraidingStyle.\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.UnitStyle-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.UnitStyle","text":"abstract type UnitStyle\nUnitStyle(::Sector)\nUnitStyle(I::Type{<:Sector})\n\nTrait to describe the semisimplicity of the unit sector of type I. This can be either\n\nSimpleUnit: the unit is simple (e.g. fusion categories).\nGenericUnit: the unit is semisimple (e.g. multifusion categories).\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.SimpleUnit-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.SimpleUnit","text":"struct SimpleUnit <: UnitStyle\n\nUnit style for fusion categories with a unique unit (identity) object. The unit satisfies mathbb1  a  a  a  mathbb1 for all sectors.\n\nSee also UnitStyle.\n\n\n\n\n\n","category":"type"},{"location":"interface/traits/#TensorKitSectors.GenericUnit-interface-traits","page":"Traits and Styles","title":"TensorKitSectors.GenericUnit","text":"struct GenericUnit <: UnitStyle\n\nUnit style for multifusion categories with multiple unit objects (semisimple unit). Requires implementation of allunits(::Type{I}), leftunit(a), and rightunit(a).\n\nSee also UnitStyle.\n\n\n\n\n\n","category":"type"},{"location":"sectors/anyons/fibonacci/#Fibonacci-Anyons","page":"Fibonacci","title":"Fibonacci Anyons","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#Type-Definition","page":"Fibonacci","title":"Type Definition","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#Construction","page":"Fibonacci","title":"Construction","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#Labels","page":"Fibonacci","title":"Labels","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#Physical-Interpretation","page":"Fibonacci","title":"Physical Interpretation","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#Fusion-Rules","page":"Fibonacci","title":"Fusion Rules","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#Quantum-Dimensions","page":"Fibonacci","title":"Quantum Dimensions","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#Topological-Data","page":"Fibonacci","title":"Topological Data","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#F-symbols","page":"Fibonacci","title":"F-symbols","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#R-symbols","page":"Fibonacci","title":"R-symbols","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#Braiding-Style","page":"Fibonacci","title":"Braiding Style","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#Twist","page":"Fibonacci","title":"Twist","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#Code-Examples","page":"Fibonacci","title":"Code Examples","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#Implementation-Notes","page":"Fibonacci","title":"Implementation Notes","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#Key-Values","page":"Fibonacci","title":"Key Values","text":"","category":"section"},{"location":"sectors/anyons/fibonacci/#References","page":"Fibonacci","title":"References","text":"","category":"section"},{"location":"sectors/anyons/planartrivial/#PlanarTrivial","page":"PlanarTrivial","title":"PlanarTrivial","text":"","category":"section"},{"location":"sectors/anyons/planartrivial/#Type-Definition","page":"PlanarTrivial","title":"Type Definition","text":"","category":"section"},{"location":"sectors/anyons/planartrivial/#Construction","page":"PlanarTrivial","title":"Construction","text":"","category":"section"},{"location":"sectors/anyons/planartrivial/#Labels","page":"PlanarTrivial","title":"Labels","text":"","category":"section"},{"location":"sectors/anyons/planartrivial/#Physical-Interpretation","page":"PlanarTrivial","title":"Physical Interpretation","text":"","category":"section"},{"location":"sectors/anyons/planartrivial/#Fusion-Rules","page":"PlanarTrivial","title":"Fusion Rules","text":"","category":"section"},{"location":"sectors/anyons/planartrivial/#Quantum-Dimensions","page":"PlanarTrivial","title":"Quantum Dimensions","text":"","category":"section"},{"location":"sectors/anyons/planartrivial/#Topological-Data","page":"PlanarTrivial","title":"Topological Data","text":"","category":"section"},{"location":"sectors/anyons/planartrivial/#F-symbols","page":"PlanarTrivial","title":"F-symbols","text":"","category":"section"},{"location":"sectors/anyons/planartrivial/#R-symbols","page":"PlanarTrivial","title":"R-symbols","text":"","category":"section"},{"location":"sectors/anyons/planartrivial/#Braiding-Style","page":"PlanarTrivial","title":"Braiding Style","text":"","category":"section"},{"location":"sectors/anyons/planartrivial/#Twist","page":"PlanarTrivial","title":"Twist","text":"","category":"section"},{"location":"sectors/anyons/planartrivial/#Code-Examples","page":"PlanarTrivial","title":"Code Examples","text":"","category":"section"},{"location":"sectors/anyons/planartrivial/#Implementation-Notes","page":"PlanarTrivial","title":"Implementation Notes","text":"","category":"section"},{"location":"sectors/fermions/spin/#Fermion-Spin:-FermionSpin","page":"Fermion Spin","title":"Fermion Spin: FermionSpin","text":"","category":"section"},{"location":"sectors/fermions/spin/#Type-Definition","page":"Fermion Spin","title":"Type Definition","text":"","category":"section"},{"location":"sectors/fermions/spin/#Construction","page":"Fermion Spin","title":"Construction","text":"","category":"section"},{"location":"sectors/fermions/spin/#Labels","page":"Fermion Spin","title":"Labels","text":"","category":"section"},{"location":"sectors/fermions/spin/#Physical-Interpretation","page":"Fermion Spin","title":"Physical Interpretation","text":"","category":"section"},{"location":"sectors/fermions/spin/#Fusion-Rules","page":"Fermion Spin","title":"Fusion Rules","text":"","category":"section"},{"location":"sectors/fermions/spin/#Quantum-Dimensions","page":"Fermion Spin","title":"Quantum Dimensions","text":"","category":"section"},{"location":"sectors/fermions/spin/#Topological-Data","page":"Fermion Spin","title":"Topological Data","text":"","category":"section"},{"location":"sectors/fermions/spin/#F-symbols","page":"Fermion Spin","title":"F-symbols","text":"","category":"section"},{"location":"sectors/fermions/spin/#R-symbols","page":"Fermion Spin","title":"R-symbols","text":"","category":"section"},{"location":"sectors/fermions/spin/#Braiding-Style","page":"Fermion Spin","title":"Braiding Style","text":"","category":"section"},{"location":"sectors/fermions/spin/#Twist","page":"Fermion Spin","title":"Twist","text":"","category":"section"},{"location":"sectors/fermions/spin/#Code-Examples","page":"Fermion Spin","title":"Code Examples","text":"","category":"section"},{"location":"sectors/fermions/spin/#Implementation-Notes","page":"Fermion Spin","title":"Implementation Notes","text":"","category":"section"},{"location":"sectors/fermions/spin/#Relationship-to-SU-Fermion-Parity","page":"Fermion Spin","title":"Relationship to SU‚ÇÇ √ó Fermion Parity","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#Dihedral-Groups:-DNIrrep","page":"D‚Çô (Dihedral)","title":"Dihedral Groups: DNIrrep","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#Type-Definition","page":"D‚Çô (Dihedral)","title":"Type Definition","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#Construction","page":"D‚Çô (Dihedral)","title":"Construction","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#Labels","page":"D‚Çô (Dihedral)","title":"Labels","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#DNIrrep{N}-for-N-odd","page":"D‚Çô (Dihedral)","title":"DNIrrep{N} for N odd","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#DNIrrep{N}-for-N-even","page":"D‚Çô (Dihedral)","title":"DNIrrep{N} for N even","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#Physical-Interpretation","page":"D‚Çô (Dihedral)","title":"Physical Interpretation","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#Fusion-Rules","page":"D‚Çô (Dihedral)","title":"Fusion Rules","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#Quantum-Dimensions","page":"D‚Çô (Dihedral)","title":"Quantum Dimensions","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#Topological-Data","page":"D‚Çô (Dihedral)","title":"Topological Data","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#F-symbols","page":"D‚Çô (Dihedral)","title":"F-symbols","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#R-symbols","page":"D‚Çô (Dihedral)","title":"R-symbols","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#Braiding-Style","page":"D‚Çô (Dihedral)","title":"Braiding Style","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#Basis-Conventions","page":"D‚Çô (Dihedral)","title":"Basis Conventions","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#Iteration","page":"D‚Çô (Dihedral)","title":"Iteration","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#Code-Examples","page":"D‚Çô (Dihedral)","title":"Code Examples","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#D3Irrep","page":"D‚Çô (Dihedral)","title":"D3Irrep","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#D4Irrep","page":"D‚Çô (Dihedral)","title":"D4Irrep","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#Implementation-Notes","page":"D‚Çô (Dihedral)","title":"Implementation Notes","text":"","category":"section"},{"location":"sectors/nonabelian/dn/#Character-Tables","page":"D‚Çô (Dihedral)","title":"Character Tables","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#CU(1):-U(1)-‚Ñ§","page":"CU‚ÇÅ","title":"CU(1): U(1) ‚ãâ ‚Ñ§‚ÇÇ","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#Type-Definition","page":"CU‚ÇÅ","title":"Type Definition","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#Construction","page":"CU‚ÇÅ","title":"Construction","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#Labels","page":"CU‚ÇÅ","title":"Labels","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#Physical-Interpretation","page":"CU‚ÇÅ","title":"Physical Interpretation","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#Fusion-Rules","page":"CU‚ÇÅ","title":"Fusion Rules","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#Quantum-Dimensions","page":"CU‚ÇÅ","title":"Quantum Dimensions","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#Topological-Data","page":"CU‚ÇÅ","title":"Topological Data","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#F-symbols","page":"CU‚ÇÅ","title":"F-symbols","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#R-symbols","page":"CU‚ÇÅ","title":"R-symbols","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#Braiding-Style","page":"CU‚ÇÅ","title":"Braiding Style","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#Basis-Conventions","page":"CU‚ÇÅ","title":"Basis Conventions","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#Iteration","page":"CU‚ÇÅ","title":"Iteration","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#Code-Examples","page":"CU‚ÇÅ","title":"Code Examples","text":"","category":"section"},{"location":"sectors/nonabelian/cu1/#Implementation-Notes","page":"CU‚ÇÅ","title":"Implementation Notes","text":"","category":"section"},{"location":"interface/optional/#Optional-Methods","page":"Optional Methods","title":"Optional Methods","text":"The following methods have default implementations but can be overridden for performance or to provide additional functionality.","category":"section"},{"location":"interface/optional/#Quantum-Dimensions","page":"Optional Methods","title":"Quantum Dimensions","text":"The quantum dimension of a sector is a fundamental invariant that determines the behavior of fusions and braiding. The default implementation extracts the dimension from Fsymbol via the quantum dimension formula.\n\nd_a = left frac1(F_a bara a^a)^1_a__a1  right\n\nFor many common sectors, however, the dimension is known directly from representation theory. In these cases, it can be beneficial to overload dim to bypass computing F-symbols, either for performance reasons or to enforce tighter output types. For example, dimensions of irreducible representations of groups are always integers.","category":"section"},{"location":"interface/optional/#Frobenius-Schur-Indicators","page":"Optional Methods","title":"Frobenius-Schur Indicators","text":"The Frobenius-Schur indicator and phase characterize the self-duality properties of sectors.\n\nkappa_a = textsignleft( (F_a bara a^a)^1_a__a1 right)\n\nThe indicator distinguishes real, complex, and quaternionic representations. The phase is the category-theoretic version that appears in line bending operations.","category":"section"},{"location":"interface/optional/#Scalar-Type","page":"Optional Methods","title":"Scalar Type","text":"Various utility functions exist for determining what number type is used in various parts of the topological data.\n\nnote: Note\nWhile there is a fallback definition that tries to determine the result from computing the functions on the unit sector, it is often a good idea to define this method explicitly to avoid depending on compiler heuristics to constant-fold these calls.","category":"section"},{"location":"interface/optional/#Topological-Data-Symbols","page":"Optional Methods","title":"Topological Data Symbols","text":"The Asymbol, Bsymbol and twist are derived from F- and R-symbols but are often occurring combinations. The A-symbol and B-symbol relate different ways of bending strands, while the twist is the topological spin (quantum dimension phase) of a sector.\n\nThe A-symbol A^ab_c relates splitting and fusion vertices:\n\nA^ab_c = sqrtfracd_a d_bd_c overlinekappa_a (F_bara a b^b)^1_c\n\nThe B-symbol B^ab_c relates splitting and fusion vertices:\n\nB^ab_c = sqrtfracd_a d_bd_c (F_a b barb^a)^c_1\n\nThe twist theta_a of a sector is the topological spin phase, computed as the trace of the R-matrix for braiding a sector with itself:\n\ntheta_a = frac1d_a sum_b in a otimes a d_b texttr(R^aa_b)","category":"section"},{"location":"interface/optional/#Fusion-Basis","page":"Optional Methods","title":"Fusion Basis","text":"The fusion tensor provides explicit matrix elements for the tensor product of representations. It is a rank-4 array whose components are the Clebsch-Gordan coefficients for fusing sector a and b into c. The fusion tensor is not uniquely determined by topological data alone, instead the topological data can be extracted from it when it is available. However, there is not always a concrete representation of these tensors in terms of simple Array objects, and the exact representation is not important for TensorKit.jl. For this reason, it is optional: TensorKit can work with the topological data alone. Note however that they are still required whenever we want to convert symmetric tensors to and from dense arrays.","category":"section"},{"location":"interface/optional/#TensorKitSectors.dim-interface-optional","page":"Optional Methods","title":"TensorKitSectors.dim","text":"dim(a::Sector)\n\nReturn the (quantum) dimension of the sector a.\n\n\n\n\n\n","category":"function"},{"location":"interface/optional/#TensorKitSectors.sqrtdim-interface-optional","page":"Optional Methods","title":"TensorKitSectors.sqrtdim","text":"sqrtdim(a::Sector)\n\nReturn the square root of the (quantum) dimension of sector a.\n\nThis is a performance specialization that avoids computing sqrt(1) for sectors with  UniqueFusion, preserving the number type (returning 1::Int instead of 1.0::Float64). For other sectors, it is equivalent to sqrt(dim(a)).\n\n\n\n\n\n","category":"function"},{"location":"interface/optional/#TensorKitSectors.invsqrtdim-interface-optional","page":"Optional Methods","title":"TensorKitSectors.invsqrtdim","text":"invsqrtdim(a::Sector)\n\nReturn the inverse square root of the (quantum) dimension of sector a.\n\nThis is a performance specialization that avoids computing inv(sqrt(1)) for sectors with  UniqueFusion, preserving the number type (returning 1::Int instead of 1.0::Float64). For other sectors, it is equivalent to inv(sqrt(dim(a))).\n\n\n\n\n\n","category":"function"},{"location":"interface/optional/#TensorKitSectors.frobenius_schur_indicator-interface-optional","page":"Optional Methods","title":"TensorKitSectors.frobenius_schur_indicator","text":"frobenius_schur_indicator(a::Sector)\n\nReturn the Frobenius-Schur indicator of a sector ŒΩ‚Çê  1 0 -1, which distinguishes between real, complex and quaternionic representations.\n\nSee also frobenius_schur_phase for the category-theoretic version that appears in the context of line bending.\n\n\n\n\n\n","category":"function"},{"location":"interface/optional/#TensorKitSectors.frobenius_schur_phase-interface-optional","page":"Optional Methods","title":"TensorKitSectors.frobenius_schur_phase","text":"frobenius_schur_phase(a::Sector)\n\nReturn the Frobenius-Schur phase Œ∫‚Çê of a sector a, which is a complex phase that appears in the context of bending lines and is obtained from F^a aÃÖ a_a. When a == dual(a), it is restricted to Œ∫‚Çê  1 -1 and coincides with the group-theoretic version frobenius_schur_indicator. When a != dual(a), the value of Œ∫‚Çê can be gauged to be 1, though is not required to be.\n\n\n\n\n\n","category":"function"},{"location":"interface/optional/#TensorKitSectors.fusionscalartype-interface-optional","page":"Optional Methods","title":"TensorKitSectors.fusionscalartype","text":"fusionscalartype(I::Type{<:Sector}) -> Type{<:Number}\n\nReturn the scalar type of the topological data associated to fusion of the sector I. In particular, this is the scalar type of Fsymbol.\n\nSee also braidingscalartype and sectorscalartype.\n\n\n\n\n\n","category":"function"},{"location":"interface/optional/#TensorKitSectors.braidingscalartype-interface-optional","page":"Optional Methods","title":"TensorKitSectors.braidingscalartype","text":"braidingscalartype(I::Type{<:Sector}) -> Type{<:Number}\n\nReturn the scalar type of the topological data associated to braiding of the sector I. In particular, this is the scalar type of Rsymbol.\n\nSee also fusionscalartype and sectorscalartype.\n\n\n\n\n\n","category":"function"},{"location":"interface/optional/#TensorKitSectors.dimscalartype-interface-optional","page":"Optional Methods","title":"TensorKitSectors.dimscalartype","text":"dimscalartype(::Type{<:Sector}) -> Type{<:Number}\n\nReturn the scalar type of the quantum dimensions associated to sectors of type I. In particular, this is the scalar type of dim.\n\n\n\n\n\n","category":"function"},{"location":"interface/optional/#TensorKitSectors.sectorscalartype-interface-optional","page":"Optional Methods","title":"TensorKitSectors.sectorscalartype","text":"sectorscalartype(I::Type{<:Sector}) -> Type{<:Number}\n\nReturn the scalar type of the topological data of the sector I. In particular, this is a combination of the scalar type of both the Fsymbol and Rsymbol, and determines the scalar type of the fusiontensor whenever it is defined.\n\nSee also fusionscalartype and braidingscalartype.\n\n\n\n\n\n","category":"function"},{"location":"interface/optional/#TensorKitSectors.Asymbol-interface-optional","page":"Optional Methods","title":"TensorKitSectors.Asymbol","text":"Asymbol(a::I, b::I, c::I) where {I <: Sector}\n\nReturn the value of A^ab_c which appears in transforming a splitting vertex into a fusion vertex using the transformation\n\na -<-Œº-<- c                                                    b -<-ŒΩ-<- dual(a)\n     ‚à®       -> ‚àö(dim(c) / dim(b)) * Asymbol(a, b, c)[Œº, ŒΩ]         ‚àß\n     b                                                              c\n\nIf FusionStyle(I) is UniqueFusion() or SimpleFusion(), the A-symbol is a number. Otherwise it is a square matrix with row and column size Nsymbol(a, b, c) == Nsymbol(dual(a), c, b).\n\n\n\n\n\n","category":"function"},{"location":"interface/optional/#TensorKitSectors.Bsymbol-interface-optional","page":"Optional Methods","title":"TensorKitSectors.Bsymbol","text":"Bsymbol(a::I, b::I, c::I) where {I <: Sector}\n\nReturn the value of B^ab_c which appears in transforming a splitting vertex into a fusion vertex using the transformation\n\na -<-Œº-<- c                                                    a -<-ŒΩ-<- c\n     ‚à®       -> ‚àö(dim(c) / dim(a)) * Bsymbol(a, b, c)[Œº, ŒΩ]         ‚àß\n     b                                                            dual(b)\n\nIf FusionStyle(I) is UniqueFusion() or SimpleFusion(), the B-symbol is a number. Otherwise it is a square matrix with row and column size Nsymbol(a, b, c) == Nsymbol(c, dual(b), a).\n\n\n\n\n\n","category":"function"},{"location":"interface/optional/#TensorKitSectors.twist-interface-optional","page":"Optional Methods","title":"TensorKitSectors.twist","text":"twist(a::Sector)\n\nReturn the twist of a sector a.\n\n\n\n\n\n","category":"function"},{"location":"interface/optional/#TensorKitSectors.fusiontensor-interface-optional","page":"Optional Methods","title":"TensorKitSectors.fusiontensor","text":"fusiontensor(a::I, b::I, c::I) where {I <: Sector} -> AbstractArray{T, 4}\n\nReturn the fusion tensor for the fusion a ‚äó b -> c. The dimensions of the returned array are (dim(a), dim(b), dim(c), Nsymbol(a, b, c)). The components of the fusion tensor are simply the Clebsch-Gordan coefficients, describing the unitary basis change from the tensor product of irreps a and b to the coupled irrep c.\n\n\n\n\n\n","category":"function"},{"location":"sectors/fermions/parity/#Fermion-Parity:-FermionParity","page":"Fermion Parity","title":"Fermion Parity: FermionParity","text":"","category":"section"},{"location":"sectors/fermions/parity/#Type-Definition","page":"Fermion Parity","title":"Type Definition","text":"","category":"section"},{"location":"sectors/fermions/parity/#Construction","page":"Fermion Parity","title":"Construction","text":"","category":"section"},{"location":"sectors/fermions/parity/#Labels","page":"Fermion Parity","title":"Labels","text":"","category":"section"},{"location":"sectors/fermions/parity/#Physical-Interpretation","page":"Fermion Parity","title":"Physical Interpretation","text":"","category":"section"},{"location":"sectors/fermions/parity/#Fusion-Rules","page":"Fermion Parity","title":"Fusion Rules","text":"","category":"section"},{"location":"sectors/fermions/parity/#Quantum-Dimensions","page":"Fermion Parity","title":"Quantum Dimensions","text":"","category":"section"},{"location":"sectors/fermions/parity/#Topological-Data","page":"Fermion Parity","title":"Topological Data","text":"","category":"section"},{"location":"sectors/fermions/parity/#F-symbols","page":"Fermion Parity","title":"F-symbols","text":"","category":"section"},{"location":"sectors/fermions/parity/#R-symbols","page":"Fermion Parity","title":"R-symbols","text":"","category":"section"},{"location":"sectors/fermions/parity/#Braiding-Style","page":"Fermion Parity","title":"Braiding Style","text":"","category":"section"},{"location":"sectors/fermions/parity/#Twist","page":"Fermion Parity","title":"Twist","text":"","category":"section"},{"location":"sectors/fermions/parity/#Code-Examples","page":"Fermion Parity","title":"Code Examples","text":"","category":"section"},{"location":"sectors/fermions/parity/#Implementation-Notes","page":"Fermion Parity","title":"Implementation Notes","text":"","category":"section"},{"location":"sectors/fermions/parity/#Relationship-to-Super-Vector-Spaces","page":"Fermion Parity","title":"Relationship to Super Vector Spaces","text":"","category":"section"},{"location":"sectors/nonabelian/su2/#SU(2)-Representations:-SU2Irrep","page":"SU‚ÇÇ","title":"SU(2) Representations: SU2Irrep","text":"SU2Irrep represents irreducible representations of the compact group SU(2) as a Sector. This page documents how the type behaves in code (construction, iteration, fusion, and access to topological data).","category":"section"},{"location":"sectors/nonabelian/su2/#Sector-type","page":"SU‚ÇÇ","title":"Sector type","text":"The irreducible representations of SU(2) are labeled by non-negative half-integers (e.g. 0, frac12, 1, frac32, ‚Ä¶).\n\nFusing two irreps together leads to a direct sum of irreps:\n\na otimes b = bigoplus_c_j = j_a - j_b^j_a + j_b c\n\nSince each output appears only once, we have FusionStyle(SU2Irrep) = SimpleFusion(). The Nsymbol returns a Bool that checks the triangle inequality:\n\nN_c^ab = j_a - j_b leq j_c leq j_a + j_b land j_a + j_b + j_c in mathbbN\n\nEach irrep has dimension d = 2j + 1.\n\nThe Fsymbol is computed from Wigner 6j (Racah-W) symbols as\n\nleft(F_abc^dright)_e^f = (-1)^j_a + j_b + j_c + j_e sqrtd_e d_f  beginBmatrix\nj_a  j_b  j_d \nj_c  j_e  j_f\nendBmatrix\n\nThe BraidingStyle is Bosonic, and Rsymbol is pm 1 for allowed fusion channels based on the parity of j_a + j_b - j_c.","category":"section"},{"location":"sectors/nonabelian/su2/#Fusion-Tensor-and-Basis-Conventions","page":"SU‚ÇÇ","title":"Fusion Tensor and Basis Conventions","text":"fusiontensor(a, b, c) returns Clebsch‚ÄìGordan coefficients as a rank‚Äë4 array of size d_a times d_b times d_c times 1. We can label the basis by using ketj m, where the magnetic quantum number takes on values m in j j-1 ldots -j (in that order).\n\nEach irrep acts on the standard basis lvert j m rangle where m = j j-1 dots -j. In that basis, the generators of mathfraksu(2) are represented by the usual angular momentum operators:\n\nJ_z lvert j m rangle = m lvert j m rangle quad\nJ_pm lvert j m rangle = sqrt(j mp m)(j pm m + 1) lvert j m pm 1 rangle\n\nusing TensorKitSectors\n\nfunction generators(a::SU2Irrep)\n    Jp = zeros(dim(a), dim(a))\n    Jm = zeros(dim(a), dim(a))\n    Jz = zeros(dim(a), dim(a))\n    \n    for row in axes(Jp, 1), col in axes(Jp, 2)\n        m = a.j - col + 1\n        if row == col\n            Jz[row, col] = m\n        elseif row + 1 == col\n            Jp[row, col] = sqrt((a.j - m) * (a.j + m + 1))\n        elseif row == col + 1\n            Jm[row, col] = sqrt((a.j + m) * (a.j - m + 1))\n        end\n    end\n\n    return Jp, Jm, Jz\nend\n\na = SU2Irrep(1)\nJp, Jm, Jz = generators(a)\n\nThe tensor product representation for a otimes b is given in terms of the representations a and b as:\n\nmathbfJ^(a otimes b) = mathbfJ^(a) otimes mathbf1^(b) + mathbf1^(a) otimes mathbfJ^(b)\n\nThe fusiontensor supplies the change‚Äëof‚Äëbasis coefficients C^J M_j_a m_a j_b m_b that map the uncoupled product basis to the coupled basis:\n\nlvert J M rangle = sum_m_a m_b C^J M_j_a m_a j_b m_b\nlvert j_a m_a rangle otimes lvert j_b m_b rangle\n\nIn particular, this block-diagonalizes the generators, and we must have that for every mathbfJ, the following holds:\n\nleft(mathbfJ^(a) otimes mathbf1^(b) + mathbf1^(a) otimes mathbfJ^(b)right) cdot C^c_ab =\n    C^c_ab cdot mathbfJ^(c)\n\nusing TensorOperations: @tensor\nusing Test: @test\n\na = SU2Irrep(1)\nb = SU2Irrep(1)\n\nfor c in a ‚äó b\n    CGC = dropdims(fusiontensor(a, b, c); dims = 4) # drop trivial multiplicity dimension\n    for (ga, gb, gc) in zip(generators(a), generators(b), generators(c))\n        @tensor lhs[a b; c] := ga[a; a'] * CGC[a' b; c] + gb[b; b'] * CGC[a b'; c]\n        @tensor rhs[a b; c] := CGC[a b; c'] * gc[c'; c]\n        @test isapprox(lhs, rhs)\n    end\nend","category":"section"},{"location":"sectors/nonabelian/su2/#References","page":"SU‚ÇÇ","title":"References","text":"For a quick refresher on the group structure and representation theory (without turning this page into a math course), the following references are useful:\n\nSpecial unitary group\nSU(2)\nRepresentation theory of SU(2)\nClebsch‚ÄìGordan coefficients\nWigner 6j symbol","category":"section"},{"location":"sectors/nonabelian/su2/#TensorKitSectors.SU2Irrep-sectors-nonabelian-su2","page":"SU‚ÇÇ","title":"TensorKitSectors.SU2Irrep","text":"struct SU2Irrep <: AbstractIrrep{SU‚ÇÇ}\nSU2Irrep(j::Real)\nIrrep[SU‚ÇÇ](j::Real)\n\nRepresents irreps of the group SU‚ÇÇ. The irrep is labeled by a half integer j which can be entered as an arbitrary Real, but is stored as a HalfInt from the HalfIntegers.jl package.\n\nFields\n\nj::HalfInt: the label of the irrep, which can be any non-negative half integer.\n\n\n\n\n\n","category":"type"},{"location":"interface/required/#Required-Methods","page":"Required Methods","title":"Required Methods","text":"The following methods must be implemented for any new sector type I <: Sector. These methods are grouped by functionality to help understand their purpose.","category":"section"},{"location":"interface/required/#Defining-the-Set-of-Sectors","page":"Required Methods","title":"Defining the Set of Sectors","text":"A sector type I <: Sector represents the set of all labels that can be used to grade a vector space. This corresponds to all irreducible representations of a group, or all simple objects in a fusion category. The first requirement is making this set enumerable through the iterator interface.\n\nThe set of all sector values is obtained via values(I), which returns a SectorValues{I}() singleton type by default. This SectorValues{I}() must be iterable, enabling enumeration of all sectors of type I. To do so, one needs to implement the Iteration interface. In particular, we require the following methods to be defined:\n\nBase.iterate(::SectorValues{I}, state...) ‚Äî Iterate over all possible values of sector type I.\nBase.IteratorSize(::Type{SectorValues{I}}) ‚Äî Specify whether the number of sector values is known, finite, or infinite.\n\nHere the IteratorSize is either HasLength(), SizeUnknown() or IsInfinite(). If the length is known (HasLength()), we additionally require:\n\nBase.length(::SectorValues{I}): Return the number of sectors\n\nTODO: this is technically optional!\n\nBase.getindex(::SectorValues{I}, i::Int): Access the i-th sector value\nfindindex(::SectorValues{I}, c::I): Find the index of sector c\n\nnote: Note\nThe choice of IteratorSize determines how associative containers are constructed in e.g. a GradedSpace. In the case of HasLength(), an implicit mapping between the values and the position is used to enable storage through Tuples or Vectors. In the other cases one has to resort to AbstractDict-like containers. If the set of simple objects is sufficiently large, it might be beneficial to register its length as SizeUnknown() to avoid putting too much pressure on the compiler.\n\nExample: Z3Irrep\n\n# ‚Ñ§‚ÇÉ has exactly 3 irreps labeled by 0, 1, 2\nBase.iterate(::SectorValues{Z3Irrep}, i = 0) = i > 2 ? nothing : (Z2Irrep(i), i+1)\nBase.IteratorSize(::Type{SectorValues{Z3Irrep}}) = HasLength()\nBase.length(::SectorValues{Z3Irrep}) = 3\nBase.getindex(::SectorValues{Z3Irrep}, i::Int) = Z3Irrep(i-1)\nfindindex(::SectorValues{Z3Irrep}, c::Z3Irrep) = c.n + 1\n\nExample: U1Irrep\n\n# U‚ÇÅ an irrep for each integer: 0, 1, -1, 2, -2, ...\nBase.iterate(::SectorValues{U1Irrep}, i = 0) = (U1Irrep(i), i <= 0 ? (-i + 1) : -i - 1)\nBase.IteratorSize(::Type{SectorValues{U1Irrep}}) = IsInfinite()","category":"section"},{"location":"interface/required/#Fusion-Structure","page":"Required Methods","title":"Fusion Structure","text":"The fusion structure describes how sectors combine when taking tensor products. In code, a ‚äó b returns the allowed output labels, and Nsymbol(a, b, c) tells you whether (or how many times) c appears.\n\nThe formal decomposition is:\n\na  b = bigoplus_c N^ab_c  c\n\nwhere N^ab_c is the fusion multiplicity.\n\nThe fusion structure is defined through three related methods:\n\nExample: U‚ÇÅ (Unique Fusion)\n\n‚äó(c1::U1Irrep, c2::U1Irrep) = (U1Irrep(charge(c1) + charge(c2)),)\nNsymbol(c1::U1Irrep, c2::U1Irrep, c3::U1Irrep) = charge(c1) + charge(c2) == charge(c3)\nFusionStyle(::Type{U1Irrep}) = UniqueFusion()\n\nExample: SU‚ÇÇ (Simple Fusion) TODO: finish this example\n\nfunction ‚äó(s1::SU2Irrep, s2::SU2Irrep)\n    return SectorProductIterator(s1, s2)  # Yields SU2Irrep(j) for j ‚àà [|j1-j2|, j1+j2]\nend\n\nfunction Nsymbol(s1::SU2Irrep, s2::SU2Irrep, s3::SU2Irrep)\n    j1, j2, j3 = spin(s1), spin(s2), spin(s3)\n    return abs(j1 - j2) <= j3 <= j1 + j2 && isinteger(j1 + j2 + j3)\nend\n\nFusionStyle(::Type{SU2Irrep}) = SimpleFusion()","category":"section"},{"location":"interface/required/#Identity-and-Duality","page":"Required Methods","title":"Identity and Duality","text":"Every sector type has a unit (identity) label and a notion of dual (conjugate). unit returns the identity label, and dual returns the label that fuses with a to give the unit.\n\nThe unit mathbb1 acts as the identity under fusion:\n\nmathbb1  a  a  a  mathbb1\n\nThe dual of a sector a is the unique sector bara such that:\n\nN^abara_mathbb1 = 1 quad textand quad N^baraa_mathbb1 = 1\n\nExample: U‚ÇÅ\n\nunit(::Type{U1Irrep}) = U1Irrep(0)         # charge 0 is the unit\ndual(c::U1Irrep) = U1Irrep(-charge(c))    # opposite charge\n\nExample: SU‚ÇÇ\n\nunit(::Type{SU2Irrep}) = SU2Irrep(0)      # spin 0 is the unit\ndual(s::SU2Irrep) = s                      # self-dual\n\nMultifusion categories can have multiple units and may distinguish between left and right units. For such cases, additional methods are available:\n\nFor regular fusion categories the unit object is unique, such that unit, leftunit and rightunit all coincide.","category":"section"},{"location":"interface/required/#Associativity","page":"Required Methods","title":"Associativity","text":"The associativity of the fusion tensor product tells us how to relate the basis states (a  b  e)  c  drangle to the states a  (b  c  f)  drangle. This is encoded in the F-symbols, which give the coefficients to transform the different ways of fusing three sectors to one.\n\nFormally, the F-symbol F^abc_d with intermediate sectors e and f is a linear transformation between the two different parenthesizations:\n\n(F_abc^d)^e_f  (a  b  e)  c  d quad longrightarrow quad a  (b  c  f)  d\n\nFor sectors with UniqueFusion or SimpleFusion, the F-symbol is a scalar <:Number. For GenericFusion, it is a rank-4 tensor with indices corresponding to the multiplicity labels of each fusion vertex.\n\nThe F-symbols must satisfy the pentagon equation for every choice of sectors:\n\n(F_fcd^e)^g_h (F_abh^e)^f_i = (F_abc^g)^f_j (F_ajd^e)^g_i (F_bcd^i)^j_h\n\nThis ensures that all ways of reassociating four tensor factors (((a  b)  c)  d) to (a  (b  (c  d))) give the same result, regardless of the sequence of reassociations.\n\nExamples: TODO: fix these examples\n\n# Trivial category: all F-symbols are 1\nFsymbol(::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial) = 1\n\n# U‚ÇÅ irreps: all F-symbols are 1 (canonical gauge choice)\nFsymbol(a::U1Irrep, b::U1Irrep, c::U1Irrep, d::U1Irrep, e::U1Irrep, f::U1Irrep) = 1\n\n# SU‚ÇÇ irreps: computed from 6j-symbols\nFsymbol(a::SU2Irrep, b::SU2Irrep, c::SU2Irrep, d::SU2Irrep, e::SU2Irrep, f::SU2Irrep) = ...","category":"section"},{"location":"interface/required/#Braiding","page":"Required Methods","title":"Braiding","text":"Sectors can have a braiding structure that describes the effect of exchanging two tensor factors. The braiding is encoded in the R-symbol R^ab_c, which is a linear transformation between the fusion channels a  b  c and b  a  c. For sectors with UniqueFusion or SimpleFusion, the R-symbol is a complex phase. For GenericFusion, it is a square matrix relating the multiplicity spaces of the two fusion orders.\n\nThe R-symbols must satisfy the hexagon equations together with the F-symbols:\n\nR^cd_e (overlineF_dab^e)^g_c overlineR^da_g = (F_abd^e)^c_f R^bd_f (overlineF_adb^e)^g_f\n\nand the analogous equation with a and b swapped. These ensure that the braiding is compatible with the associativity encoded by F-symbols.\n\nThe BraidingStyle trait categorizes behavior into four classes:\n\nNoBraiding() for planar categories where braiding is undefined\nBosonic() for symmetric braiding with trivial twist (all R-symbols square to identity, all twists equal +1)\nFermionic() for symmetric braiding with fermion parity (twists can be ¬±1)\nAnyonic() for general braiding with arbitrary phases or non-symmetric exchange\n\nExamples: TODO: fix these examples\n\n# Trivial category: bosonic braiding, all R-symbols are 1\nBraidingStyle(::Type{Trivial}) = Bosonic()\nRsymbol(::Trivial, ::Trivial, ::Trivial) = 1\n\n# Fermion parity: fermionic braiding\nBraidingStyle(::Type{FermionParity}) = Fermionic()\nRsymbol(a::FermionParity, b::FermionParity, c::FermionParity) = \n    iseven(a) || iseven(b) ? 1 : -1\n\n# Fibonacci anyons: anyonic braiding\nBraidingStyle(::Type{FibonacciAnyon}) = Anyonic()\nRsymbol(::FibonacciAnyon, ::FibonacciAnyon, ::FibonacciAnyon) = exp(4œÄ*im/5)\n\n# Planar trivial: no braiding\nBraidingStyle(::Type{PlanarTrivial}) = NoBraiding()","category":"section"},{"location":"interface/required/#Utility-Methods","page":"Required Methods","title":"Utility Methods","text":"Sectors must support a deterministic ordering and hashing so they can be used as dictionary keys, sorted collections, and canonical fusion outputs. One should keep the order consistent with values(I), i.e. the enumeration of objects should happen in a sorted fashion. To achieve this, we must have\n\nBase.isless(::Sector, ::Sector) ‚Äî Define an order on the sectors.\nBase.hash(::Sector, h::UInt) ‚Äî Associate a hash value with a sector.\n\nExample: U‚ÇÅ\n\n# U‚ÇÅ: order by absolute charge, then prefer positive over negative to comply with `values(U1Irrep)`\nfunction Base.isless(c1::U1Irrep, c2::U1Irrep)\n    q1, q2 = charge(c1), charge(c2)\n    return abs(q1) < abs(q2) || (abs(q1) == abs(q2) && q1 > q2 > 0)\nend\n\n# Hash consistent with equality\nBase.hash(c::U1Irrep, h::UInt) = hash(c.charge, h)","category":"section"},{"location":"interface/required/#TensorKitSectors.:‚äó-interface-required","page":"Required Methods","title":"TensorKitSectors.:‚äó","text":"‚äó(a::I, b::I...) where {I <: Sector}\notimes(a::I, b::I...) where {I <: Sector}\n\nReturn an iterable of elements of c::I that appear in the fusion product a ‚äó b. Each sector c should appear at most once in this iteration, even if the multiplicity N_c^ab  1. The actual multiplicities are accessed separately through Nsymbol.\n\nThe return type is typically SectorProductIterator{I} which provides a type-stable iterable that supports pretty-printing, but could also be any custom iterable.\n\nSee also FusionStyle for the trait associated to the fusion behavior of a given sector type.\n\n\n\n\n\n","category":"function"},{"location":"interface/required/#TensorKitSectors.Nsymbol-interface-required","page":"Required Methods","title":"TensorKitSectors.Nsymbol","text":"Nsymbol(a::I, b::I, c::I) where {I <: Sector} -> Integer\n\nThe fusion multiplicity N_c^ab, indicating how many times sector c appears in the fusion product a ‚äó b.\n\nThe return type depends on the [FusionStyle](@ref), where UniqueFusion and SimpleFusion return Bool values, while [GenericFusion] returns Int.\n\nSee also ‚äó to obtain the set of sectors c that appear in a ‚äó b.\n\n\n\n\n\n","category":"function"},{"location":"interface/required/#TensorKitSectors.FusionStyle-interface-required","page":"Required Methods","title":"TensorKitSectors.FusionStyle","text":"abstract type FusionStyle\nFusionStyle(::Sector)\nFusionStyle(I::Type{<:Sector})\n\nTrait to describe the fusion behavior of sectors of type I, which can be either\n\nUniqueFusion: each fusion a ‚äó b has exactly one output c.\nSimpleFusion: fusing a ‚äó b can lead to multiple values c, but each appears at most once.\nGenericFusion: fusing a ‚äó b can lead to multiple values c that could appear multiple times.\n\nThere is an abstract supertype MultipleFusion of which both SimpleFusion and GenericFusion are subtypes. Furthermore, there is a type alias MultiplicityFreeFusion for those fusion types which do not require muliplicity labels.\n\n\n\n\n\n","category":"type"},{"location":"interface/required/#TensorKitSectors.unit-interface-required","page":"Required Methods","title":"TensorKitSectors.unit","text":"unit(::Sector) -> Sector\nunit(::Type{<:Sector}) -> Sector\n\nReturn the unit element of this type of sector, provided it is unique.\n\n\n\n\n\n","category":"function"},{"location":"interface/required/#TensorKitSectors.dual-interface-required","page":"Required Methods","title":"TensorKitSectors.dual","text":"dual(a::Sector) -> Sector\n\nReturn the dual label of a, i.e. the unique label aÃÑ = dual(a) such that  Nsymbol(a, aÃÑ, leftunit(a)) == 1 and Nsymbol(aÃÑ, a, rightunit(a)) == 1.\n\n\n\n\n\n","category":"function"},{"location":"interface/required/#TensorKitSectors.allunits-interface-required","page":"Required Methods","title":"TensorKitSectors.allunits","text":"allunits(I::Type{<:Sector}) -> Tuple{I}\n\nReturn a tuple with all units of the sector type I. For fusion categories, this will contain only one element.\n\n\n\n\n\n","category":"function"},{"location":"interface/required/#TensorKitSectors.leftunit-interface-required","page":"Required Methods","title":"TensorKitSectors.leftunit","text":"leftunit(a::Sector) -> Sector\n\nReturn the left unit element corresponding to a; this is necessary for multifusion categories, where the unit may not be unique. See also rightunit and unit.\n\n\n\n\n\n","category":"function"},{"location":"interface/required/#TensorKitSectors.rightunit-interface-required","page":"Required Methods","title":"TensorKitSectors.rightunit","text":"rightunit(a::Sector) -> Sector\n\nReturn the right unit element corresponding to a; this is necessary for multifusion categories, where the unit may not be unique. See also leftunit and unit.\n\n\n\n\n\n","category":"function"},{"location":"interface/required/#TensorKitSectors.Fsymbol-interface-required","page":"Required Methods","title":"TensorKitSectors.Fsymbol","text":"Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I <: Sector}\n\nReturn the F-symbol F^abc_d that associates the two different fusion orders of sectors a, b and c into an ouput sector d, using either an intermediate sector a  b  e or b  c  f:\n\na-<-Œº-<-e-<-ŒΩ-<-d                                     a-<-Œª-<-d\n    ‚à®       ‚à®       -> Fsymbol(a,b,c,d,e,f)[Œº,ŒΩ,Œ∫,Œª]      ‚à®\n    b       c                                             f\n                                                          v\n                                                      b-<-Œ∫\n                                                          ‚à®\n                                                          c\n\nIf FusionStyle(I) is UniqueFusion or SimpleFusion, the F-symbol is a number. Otherwise it is a rank 4 array of size (Nsymbol(a, b, e), Nsymbol(e, c, d), Nsymbol(b, c, f), Nsymbol(a, f, d)).\n\n\n\n\n\n","category":"function"},{"location":"interface/required/#TensorKitSectors.Rsymbol-interface-required","page":"Required Methods","title":"TensorKitSectors.Rsymbol","text":"Rsymbol(a::I, b::I, c::I) where {I <: Sector}\n\nReturns the R-symbol R^ab_c that maps between c  a  b and c  b  a as in\n\na -<-Œº-<- c                                 b -<-ŒΩ-<- c\n     ‚à®        -> Rsymbol(a, b, c)[Œº, ŒΩ]          v\n     b                                           a\n\nIf FusionStyle(I) is UniqueFusion() or SimpleFusion(), the R-symbol is a number. Otherwise it is a square matrix with row and column size Nsymbol(a, b, c) == Nsymbol(b, a, c).\n\n\n\n\n\n","category":"function"},{"location":"interface/required/#TensorKitSectors.BraidingStyle-interface-required","page":"Required Methods","title":"TensorKitSectors.BraidingStyle","text":"abstract type BraidingStyle\nBraidingStyle(::Sector) -> ::BraidingStyle\nBraidingStyle(I::Type{<:Sector}) -> ::BraidingStyle\n\nTrait to describe the braiding behavior of sectors of type I, which can be either\n\nNoBraiding: no braiding structure defined.\nBosonic: symmetric braiding structure with a trivial twist.\nFermionic: symmetric braiding structure with a non-trivial twist that squares to identity.\nAnyonic: general braiding structure and arbitrary twists.\n\nThere is an abstract supertype HasBraiding that includes all styles that define Rsymbol (everything but NoBraiding). Furthermore, the abstract supertype SymmetricBraiding denotes the cases where braidings are equivalent to crossings, i.e. braiding twice is an identity operation. This includes the Bosonic and Fermionic styles, for which we can uniquely define permutations.\n\n\n\n\n\n","category":"type"},{"location":"sectors/composite/product/#Product-Sectors:-ProductSector","page":"Product","title":"Product Sectors: ProductSector","text":"","category":"section"},{"location":"sectors/composite/product/#Type-Definition","page":"Product","title":"Type Definition","text":"","category":"section"},{"location":"sectors/composite/product/#Construction","page":"Product","title":"Construction","text":"","category":"section"},{"location":"sectors/composite/product/#Direct-Construction","page":"Product","title":"Direct Construction","text":"","category":"section"},{"location":"sectors/composite/product/#Using-the-Operator","page":"Product","title":"Using the ‚ä† Operator","text":"","category":"section"},{"location":"sectors/composite/product/#Labels","page":"Product","title":"Labels","text":"","category":"section"},{"location":"sectors/composite/product/#Combining-Symmetries","page":"Product","title":"Combining Symmetries","text":"","category":"section"},{"location":"sectors/composite/product/#Fusion-Rules","page":"Product","title":"Fusion Rules","text":"","category":"section"},{"location":"sectors/composite/product/#Quantum-Dimensions","page":"Product","title":"Quantum Dimensions","text":"","category":"section"},{"location":"sectors/composite/product/#Topological-Data","page":"Product","title":"Topological Data","text":"","category":"section"},{"location":"sectors/composite/product/#F-symbols","page":"Product","title":"F-symbols","text":"","category":"section"},{"location":"sectors/composite/product/#R-symbols","page":"Product","title":"R-symbols","text":"","category":"section"},{"location":"sectors/composite/product/#Braiding-Style","page":"Product","title":"Braiding Style","text":"","category":"section"},{"location":"sectors/composite/product/#Code-Examples","page":"Product","title":"Code Examples","text":"","category":"section"},{"location":"sectors/composite/product/#Implementation-Notes","page":"Product","title":"Implementation Notes","text":"","category":"section"},{"location":"sectors/composite/product/#Type-Parameters","page":"Product","title":"Type Parameters","text":"","category":"section"},{"location":"sectors/composite/product/#Deligne-Tensor-Product","page":"Product","title":"Deligne Tensor Product","text":"","category":"section"},{"location":"interface/guidelines/#Implementation-Guidelines","page":"Implementation Guidelines","title":"Implementation Guidelines","text":"This section provides practical advice for implementing new sector types efficiently and correctly.","category":"section"},{"location":"interface/guidelines/#Helper-Type:-SectorProductIterator","page":"Implementation Guidelines","title":"Helper Type: SectorProductIterator","text":"Instead of materializing all fusion outputs in a tuple or array, one can use SectorProductIterator for type-stable, lazy iteration.\n\nThis is enabled by default, and new sectors should provide implementations for the following functions:\n\nBase.iterate(ab::SectorProductIterator{I}, [state]) = ...\n# optional optimizations:\nBase.IteratorSize(::Type{SectorProductIterator{I}}) = HasLength()\nBase.length(ab::SectorProductIterator{I}) = ...\n\nThis has the benefit of helping with type stability, and has a pretty-printing overload:\n\nusing TensorKitSectors # hide\nSU2Irrep(1) ‚äó SU2Irrep(1)","category":"section"},{"location":"interface/guidelines/#Shape-of-Topological-Data","page":"Implementation Guidelines","title":"Shape of Topological Data","text":"The size of Fsymbol and Rsymbol data depends on the fusion multiplicities (Nsymbol). For multiplicity‚Äëfree sectors scalars are sufficient; for generic fusion we need arrays. Therefore, we distinguish the behavior through the FusionStyle.","category":"section"},{"location":"interface/guidelines/#[MultiplicityFreeFusion](@ref)","page":"Implementation Guidelines","title":"MultiplicityFreeFusion","text":"Nsymbol(a, b, c): Returns a Bool.\nFsymbol(a, b, c, d, e, f): Returns a scalar of type sectorscalartype(I).\nRsymbol(a, b, c): Returns a scalar of type sectorscalartype(I).\n\nAdditionally, if the Fsymbol and Rsymbol do not correspond to valid fusion channels, the result is 0. Therefore, computing the number of valid fusion channels for both diagrams as the product of the relevant Nsymbols, we have:\n\nleft(N^ab_e N^ec_d = 0 lor N^af_d N^bc_f = 0right) implies (F_abc^d)^e_f = 0\n\nN^ab_c = 0 implies R^ab_c = 0","category":"section"},{"location":"interface/guidelines/#[GenericFusion](@ref)","page":"Implementation Guidelines","title":"GenericFusion","text":"Nsymbol(a, b, c): Returns a positive Integer.\nFsymbol(a, b, c, d, e, f): Returns a N^ab_e times N^ec_d times N^af_d times N^bc_f array of sectorscalartype(I) elements.\nRsymbol(a, b, c): Returns a N^ab_c times N^ba_c array of sectorscalartype(I) elements.\n\nHere invalid fusion channels will necessarily lead to empty arrays.","category":"section"},{"location":"interface/guidelines/#TensorKitSectors.SectorProductIterator-interface-guidelines","page":"Implementation Guidelines","title":"TensorKitSectors.SectorProductIterator","text":"struct SectorProductIterator{I <: Sector}\nSectorProductIterator(a::I, b::I) where {I <: Sector}\n\nCustom iterator to represent the (unique) fusion outputs of a  b.\n\nCustom sectors that aim to use this have to provide the following functionality:\n\nBase.iterate(::SectorProductIterator{I}, state...) where {I <: Sector}: iterate over   the fusion outputs of a ‚äó b\n\nIf desired and it is possible to easily compute the number of unique fusion outputs, it is also possible to define Base.IteratorSize(::Type{SectorProductIterator{I}}) = Base.HasLength(), in which case Base.length(::SectorProductIterator{I}) has to be implemented.\n\nSee also ‚äó.\n\n\n\n\n\n","category":"type"},{"location":"sectors/#Sector-Types","page":"Overview","title":"Sector Types","text":"This page provides an overview of the concrete sector types implemented in TensorKitSectors.jl.","category":"section"},{"location":"sectors/#Summary-Table","page":"Overview","title":"Summary Table","text":"Sector Type Group/Category Fusion Style Braiding Infinite? Common Use Cases\nTrivial Trivial group Unique Bosonic No No symmetry\nZNIrrep ‚Ñ§‚Çô (cyclic) Unique Bosonic No Clock models, discrete symmetries\nU1Irrep U(1) Unique Bosonic Yes Particle number, charge conservation\nSU2Irrep SU(2) Simple Bosonic Yes Spin systems, angular momentum\nCU1Irrep U(1) ‚ãä ‚Ñ§‚ÇÇ Simple Bosonic Yes Particle-hole symmetry, O(2)\nDNIrrep D‚Çô (dihedral) Simple Bosonic No Molecular/crystal symmetries\nA4Irrep A‚ÇÑ (alternating) Generic Bosonic No Tetrahedral symmetry\nFibonacciAnyon Fibonacci category Simple Anyonic No Topological quantum computing\nIsingAnyon Ising category Simple Anyonic No Majorana fermions, ŒΩ=5/2 QHE\nFermionParity f‚Ñ§‚ÇÇ Unique Fermionic No Fermion parity conservation\nFermionNumber fU‚ÇÅ Unique Fermionic Yes Fermion number conservation\nFermionSpin fSU‚ÇÇ Simple Fermionic Yes Fermions with spin symmetry\nProductSector Product categories Varies Varies Varies Multiple simultaneous symmetries\nTimeReversed Inverted braiding Varies Varies Varies ??","category":"section"},{"location":"sectors/fermions/number/#Fermion-Number:-FermionNumber","page":"Fermion Number","title":"Fermion Number: FermionNumber","text":"","category":"section"},{"location":"sectors/fermions/number/#Type-Definition","page":"Fermion Number","title":"Type Definition","text":"","category":"section"},{"location":"sectors/fermions/number/#Construction","page":"Fermion Number","title":"Construction","text":"","category":"section"},{"location":"sectors/fermions/number/#Labels","page":"Fermion Number","title":"Labels","text":"","category":"section"},{"location":"sectors/fermions/number/#Physical-Interpretation","page":"Fermion Number","title":"Physical Interpretation","text":"","category":"section"},{"location":"sectors/fermions/number/#Fusion-Rules","page":"Fermion Number","title":"Fusion Rules","text":"","category":"section"},{"location":"sectors/fermions/number/#Quantum-Dimensions","page":"Fermion Number","title":"Quantum Dimensions","text":"","category":"section"},{"location":"sectors/fermions/number/#Topological-Data","page":"Fermion Number","title":"Topological Data","text":"","category":"section"},{"location":"sectors/fermions/number/#F-symbols","page":"Fermion Number","title":"F-symbols","text":"","category":"section"},{"location":"sectors/fermions/number/#R-symbols","page":"Fermion Number","title":"R-symbols","text":"","category":"section"},{"location":"sectors/fermions/number/#Braiding-Style","page":"Fermion Number","title":"Braiding Style","text":"","category":"section"},{"location":"sectors/fermions/number/#Twist","page":"Fermion Number","title":"Twist","text":"","category":"section"},{"location":"sectors/fermions/number/#Code-Examples","page":"Fermion Number","title":"Code Examples","text":"","category":"section"},{"location":"sectors/fermions/number/#Implementation-Notes","page":"Fermion Number","title":"Implementation Notes","text":"","category":"section"},{"location":"sectors/fermions/number/#Relationship-to-U-Fermion-Parity","page":"Fermion Number","title":"Relationship to U‚ÇÅ √ó Fermion Parity","text":"","category":"section"},{"location":"sectors/abelian/zn/#Cyclic-Groups:-ZNIrrep","page":"‚Ñ§‚Çô (Cyclic)","title":"Cyclic Groups: ZNIrrep","text":"","category":"section"},{"location":"sectors/abelian/zn/#Type-Definition","page":"‚Ñ§‚Çô (Cyclic)","title":"Type Definition","text":"","category":"section"},{"location":"sectors/abelian/zn/#Construction","page":"‚Ñ§‚Çô (Cyclic)","title":"Construction","text":"","category":"section"},{"location":"sectors/abelian/zn/#Labels","page":"‚Ñ§‚Çô (Cyclic)","title":"Labels","text":"","category":"section"},{"location":"sectors/abelian/zn/#ZNIrrep{N}","page":"‚Ñ§‚Çô (Cyclic)","title":"ZNIrrep{N}","text":"","category":"section"},{"location":"sectors/abelian/zn/#LargeZNIrrep{N}","page":"‚Ñ§‚Çô (Cyclic)","title":"LargeZNIrrep{N}","text":"","category":"section"},{"location":"sectors/abelian/zn/#Physical-Interpretation","page":"‚Ñ§‚Çô (Cyclic)","title":"Physical Interpretation","text":"","category":"section"},{"location":"sectors/abelian/zn/#Fusion-Rules","page":"‚Ñ§‚Çô (Cyclic)","title":"Fusion Rules","text":"","category":"section"},{"location":"sectors/abelian/zn/#Quantum-Dimensions","page":"‚Ñ§‚Çô (Cyclic)","title":"Quantum Dimensions","text":"","category":"section"},{"location":"sectors/abelian/zn/#Topological-Data","page":"‚Ñ§‚Çô (Cyclic)","title":"Topological Data","text":"","category":"section"},{"location":"sectors/abelian/zn/#F-symbols","page":"‚Ñ§‚Çô (Cyclic)","title":"F-symbols","text":"","category":"section"},{"location":"sectors/abelian/zn/#R-symbols","page":"‚Ñ§‚Çô (Cyclic)","title":"R-symbols","text":"","category":"section"},{"location":"sectors/abelian/zn/#Braiding-Style","page":"‚Ñ§‚Çô (Cyclic)","title":"Braiding Style","text":"","category":"section"},{"location":"sectors/abelian/zn/#Basis-Conventions","page":"‚Ñ§‚Çô (Cyclic)","title":"Basis Conventions","text":"","category":"section"},{"location":"sectors/abelian/zn/#Iteration","page":"‚Ñ§‚Çô (Cyclic)","title":"Iteration","text":"","category":"section"},{"location":"sectors/abelian/zn/#Code-Examples","page":"‚Ñ§‚Çô (Cyclic)","title":"Code Examples","text":"","category":"section"},{"location":"sectors/abelian/zn/#Implementation-Notes","page":"‚Ñ§‚Çô (Cyclic)","title":"Implementation Notes","text":"","category":"section"},{"location":"sectors/abelian/zn/#Storage-Details","page":"‚Ñ§‚Çô (Cyclic)","title":"Storage Details","text":"","category":"section"},{"location":"sectors/abelian/zn/#Performance-Considerations","page":"‚Ñ§‚Çô (Cyclic)","title":"Performance Considerations","text":"","category":"section"},{"location":"sectors/abelian/zn/#Related-Types","page":"‚Ñ§‚Çô (Cyclic)","title":"Related Types","text":"","category":"section"},{"location":"sectors/abelian/zn/#Z2Irrep,-Z3Irrep,-Z4Irrep","page":"‚Ñ§‚Çô (Cyclic)","title":"Z2Irrep, Z3Irrep, Z4Irrep","text":"","category":"section"},{"location":"sectors/anyons/ising/#Ising-Anyons","page":"Ising","title":"Ising Anyons","text":"","category":"section"},{"location":"sectors/anyons/ising/#Type-Definition","page":"Ising","title":"Type Definition","text":"","category":"section"},{"location":"sectors/anyons/ising/#Construction","page":"Ising","title":"Construction","text":"","category":"section"},{"location":"sectors/anyons/ising/#Labels","page":"Ising","title":"Labels","text":"","category":"section"},{"location":"sectors/anyons/ising/#Physical-Interpretation","page":"Ising","title":"Physical Interpretation","text":"","category":"section"},{"location":"sectors/anyons/ising/#Fusion-Rules","page":"Ising","title":"Fusion Rules","text":"","category":"section"},{"location":"sectors/anyons/ising/#Quantum-Dimensions","page":"Ising","title":"Quantum Dimensions","text":"","category":"section"},{"location":"sectors/anyons/ising/#Topological-Data","page":"Ising","title":"Topological Data","text":"","category":"section"},{"location":"sectors/anyons/ising/#F-symbols","page":"Ising","title":"F-symbols","text":"","category":"section"},{"location":"sectors/anyons/ising/#R-symbols","page":"Ising","title":"R-symbols","text":"","category":"section"},{"location":"sectors/anyons/ising/#Braiding-Style","page":"Ising","title":"Braiding Style","text":"","category":"section"},{"location":"sectors/anyons/ising/#Twist","page":"Ising","title":"Twist","text":"","category":"section"},{"location":"sectors/anyons/ising/#Code-Examples","page":"Ising","title":"Code Examples","text":"","category":"section"},{"location":"sectors/anyons/ising/#Implementation-Notes","page":"Ising","title":"Implementation Notes","text":"","category":"section"},{"location":"sectors/anyons/ising/#Key-Values","page":"Ising","title":"Key Values","text":"","category":"section"},{"location":"sectors/anyons/ising/#References","page":"Ising","title":"References","text":"","category":"section"},{"location":"sectors/composite/timereversed/#Time-Reversed-Sectors:-TimeReversed","page":"Time-Reversed","title":"Time-Reversed Sectors: TimeReversed","text":"","category":"section"},{"location":"sectors/composite/timereversed/#Type-Definition","page":"Time-Reversed","title":"Type Definition","text":"","category":"section"},{"location":"sectors/composite/timereversed/#Construction","page":"Time-Reversed","title":"Construction","text":"","category":"section"},{"location":"sectors/composite/timereversed/#Labels","page":"Time-Reversed","title":"Labels","text":"","category":"section"},{"location":"sectors/composite/timereversed/#Physical-Interpretation","page":"Time-Reversed","title":"Physical Interpretation","text":"","category":"section"},{"location":"sectors/composite/timereversed/#Braiding-Reversal","page":"Time-Reversed","title":"Braiding Reversal","text":"","category":"section"},{"location":"sectors/composite/timereversed/#Fusion-Rules","page":"Time-Reversed","title":"Fusion Rules","text":"","category":"section"},{"location":"sectors/composite/timereversed/#Quantum-Dimensions","page":"Time-Reversed","title":"Quantum Dimensions","text":"","category":"section"},{"location":"sectors/composite/timereversed/#Topological-Data","page":"Time-Reversed","title":"Topological Data","text":"","category":"section"},{"location":"sectors/composite/timereversed/#F-symbols","page":"Time-Reversed","title":"F-symbols","text":"","category":"section"},{"location":"sectors/composite/timereversed/#R-symbols","page":"Time-Reversed","title":"R-symbols","text":"","category":"section"},{"location":"sectors/composite/timereversed/#Braiding-Style","page":"Time-Reversed","title":"Braiding Style","text":"","category":"section"},{"location":"sectors/composite/timereversed/#Code-Examples","page":"Time-Reversed","title":"Code Examples","text":"","category":"section"},{"location":"sectors/composite/timereversed/#Implementation-Notes","page":"Time-Reversed","title":"Implementation Notes","text":"","category":"section"},{"location":"sectors/composite/timereversed/#Anti-unitary-Symmetries","page":"Time-Reversed","title":"Anti-unitary Symmetries","text":"","category":"section"},{"location":"#TensorKitSectors.jl","page":"Home","title":"TensorKitSectors.jl","text":"A Julia package for working with objects in fusion categories.\n\nThis package provides functionality for defining objects in fusion categories, along with their topological data. This includes the fusion rules, the associators, and the braiding. In particular, this is the data that is needed to define (symmetric) tensors, which are defined over vector spaces graded by these objects. For the full functionality, we refer to TensorKit.jl and its documentation.\n\nInstall via the package manager.","category":"section"},{"location":"sectors/abelian/u1/#U(1)-Representations:-U1Irrep","page":"U‚ÇÅ","title":"U(1) Representations: U1Irrep","text":"","category":"section"},{"location":"sectors/abelian/u1/#Type-Definition","page":"U‚ÇÅ","title":"Type Definition","text":"","category":"section"},{"location":"sectors/abelian/u1/#Construction","page":"U‚ÇÅ","title":"Construction","text":"","category":"section"},{"location":"sectors/abelian/u1/#Labels","page":"U‚ÇÅ","title":"Labels","text":"","category":"section"},{"location":"sectors/abelian/u1/#Physical-Interpretation","page":"U‚ÇÅ","title":"Physical Interpretation","text":"","category":"section"},{"location":"sectors/abelian/u1/#Fusion-Rules","page":"U‚ÇÅ","title":"Fusion Rules","text":"","category":"section"},{"location":"sectors/abelian/u1/#Quantum-Dimensions","page":"U‚ÇÅ","title":"Quantum Dimensions","text":"","category":"section"},{"location":"sectors/abelian/u1/#Topological-Data","page":"U‚ÇÅ","title":"Topological Data","text":"","category":"section"},{"location":"sectors/abelian/u1/#F-symbols","page":"U‚ÇÅ","title":"F-symbols","text":"","category":"section"},{"location":"sectors/abelian/u1/#R-symbols","page":"U‚ÇÅ","title":"R-symbols","text":"","category":"section"},{"location":"sectors/abelian/u1/#Braiding-Style","page":"U‚ÇÅ","title":"Braiding Style","text":"","category":"section"},{"location":"sectors/abelian/u1/#Basis-Conventions","page":"U‚ÇÅ","title":"Basis Conventions","text":"","category":"section"},{"location":"sectors/abelian/u1/#Iteration-Order","page":"U‚ÇÅ","title":"Iteration Order","text":"","category":"section"},{"location":"sectors/abelian/u1/#Code-Examples","page":"U‚ÇÅ","title":"Code Examples","text":"","category":"section"},{"location":"sectors/abelian/u1/#Implementation-Notes","page":"U‚ÇÅ","title":"Implementation Notes","text":"","category":"section"}]
}
