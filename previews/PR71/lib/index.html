<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library ¬∑ TensorKitSectors.jl</title><meta name="title" content="Library ¬∑ TensorKitSectors.jl"/><meta property="og:title" content="Library ¬∑ TensorKitSectors.jl"/><meta property="twitter:title" content="Library ¬∑ TensorKitSectors.jl"/><meta name="description" content="Documentation for TensorKitSectors.jl."/><meta property="og:description" content="Documentation for TensorKitSectors.jl."/><meta property="twitter:description" content="Documentation for TensorKitSectors.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TensorKitSectors.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKitSectors.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/main/docs/src/lib.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-documentation"><a class="docs-heading-anchor" href="#Library-documentation">Library documentation</a><a id="Library-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Library-documentation" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="TensorKitSectors.GroupElement"><a class="docstring-binding" href="#TensorKitSectors.GroupElement"><code>TensorKitSectors.GroupElement</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const GroupElement</code></pre><p>A constant of a singleton type used as <code>GroupElement[G]</code> or <code>GroupElement[G, œâ]</code> with <code>G &lt;: Group</code> a type of group, to construct or obtain a concrete subtype of <code>AbstractElement{G}</code> that implements the data structure used to represent elements of the group <code>G</code>, possibly with a second argument <code>œâ</code> that specifies the associated 3-cocycle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/groupelements.jl#L60-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Irrep"><a class="docstring-binding" href="#TensorKitSectors.Irrep"><code>TensorKitSectors.Irrep</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const Irrep</code></pre><p>A constant of a singleton type used as <code>Irrep[G]</code> with <code>G &lt;: Group</code> a type of group, to construct or obtain a concrete subtype of <code>AbstractIrrep{G}</code> that implements the data structure used to represent irreducible representations of the group <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/irreps/irreps.jl#L20-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.A4Irrep"><a class="docstring-binding" href="#TensorKitSectors.A4Irrep"><code>TensorKitSectors.A4Irrep</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct A4Irrep &lt;: AbstractIrrep{A‚ÇÑ}
A4Irrep(n::Integer)
Irrep[A‚ÇÑ](n::Integer)</code></pre><p>Represents irreps of the alternating group <span>$A‚ÇÑ$</span>.</p><p><strong>Fields</strong></p><ul><li><code>n::Int8</code>: the label of the irrep, corresponding to <span>$1$</span>, <span>$1‚Ä≤$</span>, <span>$1‚Ä≥$</span> and <span>$3$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/irreps/a4irrep.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.AbelianGroup"><a class="docstring-binding" href="#TensorKitSectors.AbelianGroup"><code>TensorKitSectors.AbelianGroup</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbelianGroup &lt;: Group</code></pre><p>Abstract supertype for representing different types of Abelian groups. Abelian groups have both irreps and group elements that have several simplified properties, that can be defined in general.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/groups.jl#L13-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.AbstractGroupElement"><a class="docstring-binding" href="#TensorKitSectors.AbstractGroupElement"><code>TensorKitSectors.AbstractGroupElement</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractGroupElement{G &lt;: Group} &lt;: Sector</code></pre><p>Abstract supertype for sectors which corresponds to group elements of a group <code>G</code>.</p><p>Actual concrete implementations of those irreps can be obtained as <code>Element[G]</code>, or via their actual name, which generically takes the form <code>(asciiG)Element</code>, i.e. the ASCII spelling of the group name followed by <code>Element</code>.</p><p>All group elements have <a href="#TensorKitSectors.FusionStyle"><code>FusionStyle</code></a> equal to <code>UniqueFusion()</code>. Furthermore, the <a href="#TensorKitSectors.BraidingStyle"><code>BraidingStyle</code></a> is set to <code>NoBraiding()</code>, although this can be overridden by a concrete implementation of <code>AbstractGroupElement</code>.</p><p>For the fusion structure, a specific <code>SomeGroupElement &lt;: AbstractGroupElement{SomeGroup}</code> should only implement the following methods</p><pre><code class="language-julia hljs">Base.:*(c1::GroupElement, c2::GroupElement) -&gt; GroupElement
Base.one(::Type{GroupElement}) -&gt; GroupElement
Base.inv(c::GroupElement) -&gt; GroupElement
# and optionally
TensorKitSectors.cocycle(c1::GroupElement, c2::GroupElement, c3::GroupElement) -&gt; Number</code></pre><p>The methods <code>conj</code>, <code>dual</code>, <code>‚äó</code>, <code>Nsymbol</code>, <code>Fsymbol</code>, <code>dim</code>, <code>Asymbol</code>, <code>Bsymbol</code> and <code>frobenius_schur_phase</code> will then be automatically defined. If no <code>cocycle</code> method is defined, the cocycle will be assumed to be trivial, i.e. equal to <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/groupelements.jl#L4-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.AbstractIrrep"><a class="docstring-binding" href="#TensorKitSectors.AbstractIrrep"><code>TensorKitSectors.AbstractIrrep</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractIrrep{G &lt;: Group} &lt;: Sector</code></pre><p>Abstract supertype for sectors which corresponds to irreps (irreducible representations) of a group <code>G</code>. As we assume unitary representations, these would be finite groups or compact Lie groups. Note that this could also include projective rather than linear representations.</p><p>Actual concrete implementations of those irreps can be obtained as <code>Irrep[G]</code>, or via their actual name, which generically takes the form <code>(asciiG)Irrep</code>, i.e. the ASCII spelling of the group name followed by <code>Irrep</code>.</p><p>All irreps have <a href="#TensorKitSectors.BraidingStyle"><code>BraidingStyle</code></a> equal to <code>Bosonic()</code> and thus trivial twists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/irreps/irreps.jl#L3-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Alternating"><a class="docstring-binding" href="#TensorKitSectors.Alternating"><code>TensorKitSectors.Alternating</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type Alternating{N} &lt;: Group</code></pre><p>Type to represent the alternating group of order <code>N!/2</code>, which is the group of even permutations on <code>N</code> elements. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/groups.jl#L41-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Anyonic"><a class="docstring-binding" href="#TensorKitSectors.Anyonic"><code>TensorKitSectors.Anyonic</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type BradingStyle
BraidingStyle(::Sector) -&gt; ::BraidingStyle
BraidingStyle(I::Type{&lt;:Sector}) -&gt; ::BraidingStyle</code></pre><p>Return the type of braiding and twist behavior of sectors of type <code>I</code>, which can be either</p><ul><li><code>NoBraiding()</code>: no braiding structure</li><li><code>Bosonic()</code>: symmetric braiding with trivial twist (i.e. identity)</li><li><code>Fermionic()</code>: symmetric braiding with non-trivial twist (squares to identity)</li><li><code>Anyonic()</code>: general <span>$R^{ab}_c$</span> phase or matrix (depending on <code>SimpleFusion</code> or   <code>GenericFusion</code> fusion) and arbitrary twists</li></ul><p>Note that <code>Bosonic</code> and <code>Fermionic</code> are subtypes of <code>SymmetricBraiding</code>, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: <code>isone(Rsymbol(b,a,c)*Rsymbol(a,b,c)) == true</code>) and permutations are uniquely defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L571-L586">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Bosonic"><a class="docstring-binding" href="#TensorKitSectors.Bosonic"><code>TensorKitSectors.Bosonic</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type BradingStyle
BraidingStyle(::Sector) -&gt; ::BraidingStyle
BraidingStyle(I::Type{&lt;:Sector}) -&gt; ::BraidingStyle</code></pre><p>Return the type of braiding and twist behavior of sectors of type <code>I</code>, which can be either</p><ul><li><code>NoBraiding()</code>: no braiding structure</li><li><code>Bosonic()</code>: symmetric braiding with trivial twist (i.e. identity)</li><li><code>Fermionic()</code>: symmetric braiding with non-trivial twist (squares to identity)</li><li><code>Anyonic()</code>: general <span>$R^{ab}_c$</span> phase or matrix (depending on <code>SimpleFusion</code> or   <code>GenericFusion</code> fusion) and arbitrary twists</li></ul><p>Note that <code>Bosonic</code> and <code>Fermionic</code> are subtypes of <code>SymmetricBraiding</code>, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: <code>isone(Rsymbol(b,a,c)*Rsymbol(a,b,c)) == true</code>) and permutations are uniquely defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L571-L586">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.BraidingStyle"><a class="docstring-binding" href="#TensorKitSectors.BraidingStyle"><code>TensorKitSectors.BraidingStyle</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type BradingStyle
BraidingStyle(::Sector) -&gt; ::BraidingStyle
BraidingStyle(I::Type{&lt;:Sector}) -&gt; ::BraidingStyle</code></pre><p>Return the type of braiding and twist behavior of sectors of type <code>I</code>, which can be either</p><ul><li><code>NoBraiding()</code>: no braiding structure</li><li><code>Bosonic()</code>: symmetric braiding with trivial twist (i.e. identity)</li><li><code>Fermionic()</code>: symmetric braiding with non-trivial twist (squares to identity)</li><li><code>Anyonic()</code>: general <span>$R^{ab}_c$</span> phase or matrix (depending on <code>SimpleFusion</code> or   <code>GenericFusion</code> fusion) and arbitrary twists</li></ul><p>Note that <code>Bosonic</code> and <code>Fermionic</code> are subtypes of <code>SymmetricBraiding</code>, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: <code>isone(Rsymbol(b,a,c)*Rsymbol(a,b,c)) == true</code>) and permutations are uniquely defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L571-L586">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.CU1Irrep"><a class="docstring-binding" href="#TensorKitSectors.CU1Irrep"><code>TensorKitSectors.CU1Irrep</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct CU1Irrep &lt;: AbstractIrrep{CU‚ÇÅ}
CU1Irrep(j, s = ifelse(j&gt;zero(j), 2, 0))
Irrep[CU‚ÇÅ](j, s = ifelse(j&gt;zero(j), 2, 0))</code></pre><p>Represents irreps of the group <span>$U‚ÇÅ ‚ãä C$</span> (<span>$U‚ÇÅ$</span> and charge conjugation or reflection), which is also known as just <code>O‚ÇÇ</code>. </p><p><strong>Fields</strong></p><ul><li><code>j::HalfInt</code>: the value of the <span>$U‚ÇÅ$</span> charge.</li><li><code>s::Int</code>: the representation of charge conjugation.</li></ul><p>They can take values:</p><ul><li>if <code>j == 0</code>, <code>s = 0</code> (trivial charge conjugation) or   <code>s = 1</code> (non-trivial charge conjugation)</li><li>if <code>j &gt; 0</code>, <code>s = 2</code> (two-dimensional representation)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/irreps/cu1irrep.jl#L2-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.CU‚ÇÅ"><a class="docstring-binding" href="#TensorKitSectors.CU‚ÇÅ"><code>TensorKitSectors.CU‚ÇÅ</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type CU‚ÇÅ &lt;: Group</code></pre><p>Type to represent the group of U‚ÇÅ in combination with charge conjugation, i.e. the group generated by U‚ÇÅ and an additional element that acts as complex conjugation on U‚ÇÅ. This group is isomorphic to the orthogonal group O‚ÇÇ of real orthogonal 2√ó2 matrices, and can be seen as the semidirect product U‚ÇÅ ‚ãä ‚Ñ§‚ÇÇ. This is a compact non-Abelian group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/groups.jl#L66-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Cyclic"><a class="docstring-binding" href="#TensorKitSectors.Cyclic"><code>TensorKitSectors.Cyclic</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type Cyclic{N} &lt;: AbelianGroup</code></pre><p>Type to represent the cyclic group of order <code>N</code>, i.e. the multiplicative group of roots of unity of order <code>N</code>, which is a discrete abelian group. The cyclic group of order <code>N</code> is isomorphic to the additive group <code>‚Ñ§{N}</code>, and we define the latter as a type alias <code>const ‚Ñ§{N} = Cyclic{N}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/groups.jl#L22-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.DNIrrep"><a class="docstring-binding" href="#TensorKitSectors.DNIrrep"><code>TensorKitSectors.DNIrrep</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DNIrrep{N} &lt;: AbstractIrrep{Dihedral{N}}
DNIrrep{N}(n::Integer, isodd::Bool=false)
Irrep[Dihedral{N}](n::Integer, isodd::Bool=false)</code></pre><p>Represents irreps of the dihedral group <span>$D_N = Z_N ‚ãä C$</span> (<span>$Z_N$</span> and charge conjugation or reflection).</p><p><strong>Properties</strong></p><ul><li><code>j::Int</code>: the value of the <span>$Z_N$</span> charge.</li><li><code>isodd::Bool</code>: the representation of charge conjugation.</li></ul><p>Combined these take the values <span>$+0, -0, 1, ..., (N - 1) / 2$</span> for odd <span>$N$</span>, and <span>$+0, -0, 1, ..., N / 2 - 1, +(N/2), -(N/2)$</span> for even <span>$N$</span>, where the <span>$+$</span> (<span>$-$</span>) refer to the even (odd) one-dimensional irreps, while the others are two-dimensional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/irreps/dnirrep.jl#L1-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Dihedral"><a class="docstring-binding" href="#TensorKitSectors.Dihedral"><code>TensorKitSectors.Dihedral</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type Dihedral{N} &lt;: Group</code></pre><p>Type to represent the dihedral group of order <code>2N</code>, which is the symmetry group of a regular polygon with <code>N</code> sides, and is a discrete non-Abelian group. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/groups.jl#L32-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.FermionNumber"><a class="docstring-binding" href="#TensorKitSectors.FermionNumber"><code>TensorKitSectors.FermionNumber</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const FermionNumber = U1Irrep ‚ä† FermionParity
FermionNumber(a::Int)</code></pre><p>Represents the fermion number as the direct product of a <span>$U‚ÇÅ$</span> irrep <code>a</code> and a fermion parity, with the restriction that the fermion parity is odd if and only if <code>a</code> is odd.</p><p>See also: <a href="#TensorKitSectors.U1Irrep"><code>U1Irrep</code></a>, <a href="#TensorKitSectors.FermionParity"><code>FermionParity</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/fermions.jl#L76-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.FermionParity"><a class="docstring-binding" href="#TensorKitSectors.FermionParity"><code>TensorKitSectors.FermionParity</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FermionParity &lt;: Sector
FermionParity(isodd::Bool)</code></pre><p>Represents sectors with fermion parity. The fermion parity is a <span>$‚Ñ§‚ÇÇ$</span> quantum number that yields an additional sign when two odd fermions are exchanged, corresponding to a <a href="#TensorKitSectors.BraidingStyle"><code>BraidingStyle</code></a> that is <code>Fermionic()</code>.</p><p><strong>Fields</strong></p><ul><li><code>isodd::Bool</code>: indicates whether the fermion parity is odd (<code>true</code>) or even (<code>false</code>).</li></ul><p>See also: <a href="#TensorKitSectors.FermionNumber"><code>FermionNumber</code></a>, <a href="#TensorKitSectors.FermionSpin"><code>FermionSpin</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/fermions.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.FermionSpin"><a class="docstring-binding" href="#TensorKitSectors.FermionSpin"><code>TensorKitSectors.FermionSpin</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const FermionSpin = SU2Irrep ‚ä† FermionParity
FermionSpin(j::Real)</code></pre><p>Represents the fermion spin as the direct product of a <span>$SU‚ÇÇ$</span> irrep <code>j</code> and a fermion parity, with the restriction that the fermion parity is odd if <code>2 * j</code> is odd.</p><p>See also: <a href="#TensorKitSectors.SU2Irrep"><code>SU2Irrep</code></a>, <a href="#TensorKitSectors.FermionParity"><code>FermionParity</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/fermions.jl#L93-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Fermionic"><a class="docstring-binding" href="#TensorKitSectors.Fermionic"><code>TensorKitSectors.Fermionic</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type BradingStyle
BraidingStyle(::Sector) -&gt; ::BraidingStyle
BraidingStyle(I::Type{&lt;:Sector}) -&gt; ::BraidingStyle</code></pre><p>Return the type of braiding and twist behavior of sectors of type <code>I</code>, which can be either</p><ul><li><code>NoBraiding()</code>: no braiding structure</li><li><code>Bosonic()</code>: symmetric braiding with trivial twist (i.e. identity)</li><li><code>Fermionic()</code>: symmetric braiding with non-trivial twist (squares to identity)</li><li><code>Anyonic()</code>: general <span>$R^{ab}_c$</span> phase or matrix (depending on <code>SimpleFusion</code> or   <code>GenericFusion</code> fusion) and arbitrary twists</li></ul><p>Note that <code>Bosonic</code> and <code>Fermionic</code> are subtypes of <code>SymmetricBraiding</code>, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: <code>isone(Rsymbol(b,a,c)*Rsymbol(a,b,c)) == true</code>) and permutations are uniquely defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L571-L586">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.FibonacciAnyon"><a class="docstring-binding" href="#TensorKitSectors.FibonacciAnyon"><code>TensorKitSectors.FibonacciAnyon</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FibonacciAnyon &lt;: Sector
FibonacciAnyon(s::Symbol)</code></pre><p>Represents the anyons of the Fibonacci modular fusion category. It can take two values, corresponding to the trivial sector <code>FibonacciAnyon(:I)</code> and the non-trivial sector <code>FibonacciAnyon(:œÑ)</code> with fusion rules <span>$œÑ ‚äó œÑ = 1 ‚äï œÑ$</span>.</p><p><strong>Fields</strong></p><ul><li><code>isunit::Bool</code>: indicates whether the sector corresponds to the trivial anyon <code>:I</code> (<code>true</code>), or the non-trivial anyon <code>:œÑ</code> (<code>false</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/anyons.jl#L40-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.FusionStyle"><a class="docstring-binding" href="#TensorKitSectors.FusionStyle"><code>TensorKitSectors.FusionStyle</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type FusionStyle
FusionStyle(::Sector)
FusionStyle(I::Type{&lt;:Sector})</code></pre><p>Trait to describe the fusion behavior of sectors of type <code>I</code>, which can be either</p><ul><li><code>UniqueFusion()</code>: single fusion output when fusing two sectors;</li><li><code>SimpleFusion()</code>: multiple outputs, but every output occurs at most one,   also known as multiplicity-free (e.g. irreps of <span>$SU(2)$</span>);</li><li><code>GenericFusion()</code>: multiple outputs that can occur more than once (e.g. irreps   of <span>$SU(3)$</span>).</li></ul><p>There is an abstract supertype <code>MultipleFusion</code> of which both <code>SimpleFusion</code> and <code>GenericFusion</code> are subtypes. Furthermore, there is a type alias <code>MultiplicityFreeFusion</code> for those fusion types which do not require muliplicity labels, i.e. <code>MultiplicityFreeFusion = Union{UniqueFusion,SimpleFusion}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L306-L322">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.GenericFusion"><a class="docstring-binding" href="#TensorKitSectors.GenericFusion"><code>TensorKitSectors.GenericFusion</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type FusionStyle
FusionStyle(::Sector)
FusionStyle(I::Type{&lt;:Sector})</code></pre><p>Trait to describe the fusion behavior of sectors of type <code>I</code>, which can be either</p><ul><li><code>UniqueFusion()</code>: single fusion output when fusing two sectors;</li><li><code>SimpleFusion()</code>: multiple outputs, but every output occurs at most one,   also known as multiplicity-free (e.g. irreps of <span>$SU(2)$</span>);</li><li><code>GenericFusion()</code>: multiple outputs that can occur more than once (e.g. irreps   of <span>$SU(3)$</span>).</li></ul><p>There is an abstract supertype <code>MultipleFusion</code> of which both <code>SimpleFusion</code> and <code>GenericFusion</code> are subtypes. Furthermore, there is a type alias <code>MultiplicityFreeFusion</code> for those fusion types which do not require muliplicity labels, i.e. <code>MultiplicityFreeFusion = Union{UniqueFusion,SimpleFusion}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L306-L322">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.GenericUnit"><a class="docstring-binding" href="#TensorKitSectors.GenericUnit"><code>TensorKitSectors.GenericUnit</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type UnitStyle
UnitStyle(::Sector)
UnitStyle(I::Type{&lt;:Sector})</code></pre><p>Trait to describe the semisimplicity of the unit sector of type <code>I</code>. This can be either</p><ul><li><code>SimpleUnit()</code>: the unit is simple (e.g. fusion categories);</li><li><code>GenericUnit()</code>: the unit is semisimple.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L345-L354">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Group"><a class="docstring-binding" href="#TensorKitSectors.Group"><code>TensorKitSectors.Group</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type Group</code></pre><p>Abstract supertype for representing different types of groups. Groups can be used to define Sector subtypes, either via their irreducible representations, or via their group elements, and typically appear as type parameter. As such, they are not meant to be instantiated and are defined as abstract types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/groups.jl#L3-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.IsingAnyon"><a class="docstring-binding" href="#TensorKitSectors.IsingAnyon"><code>TensorKitSectors.IsingAnyon</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct IsingAnyon &lt;: Sector
IsingAnyon(s::Symbol)</code></pre><p>Represents the anyons of the Ising modular fusion category. It can take three values, corresponding to the trivial sector <code>IsingAnyon(:I)</code> and the non-trivial sectors <code>IsingAnyon(:œÉ)</code> and <code>IsingAnyon(:œà)</code>, with fusion rules <span>$œà ‚äó œà = 1$</span>, <span>$œÉ ‚äó œà = œÉ$</span>, and <span>$œÉ ‚äó œÉ = 1 ‚äï œà$</span>.</p><p><strong>Fields</strong></p><ul><li><code>s::Symbol</code>: the label of the represented anyon, which can be <code>:I</code>, <code>:œÉ</code>, or <code>:œà</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/anyons.jl#L158-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.IsingBimodule"><a class="docstring-binding" href="#TensorKitSectors.IsingBimodule"><code>TensorKitSectors.IsingBimodule</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct IsingBimodule &lt;: Sector</code></pre><p>Type to represent the simple objects in the Ising category reinterpreted as a bimodule category composed of two copies of the category ùíû = ùíü = Irrep[‚Ñ§‚ÇÇ], the two simple objects of which can be identified with the Ising anyons {I, œà}, and the bimodule categories ‚Ñ≥ = ‚Ñ≥·µí·µñ = Vec, with a single simple object that can be identified with the Ising anyon œÉ. This constitutes the easiest example of a multifusion category and is implemented here for testing purposes and to illustrate how to implement such categories in TensorKitSectors.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/multifusion.jl#L5-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.LargeZNIrrep"><a class="docstring-binding" href="#TensorKitSectors.LargeZNIrrep"><code>TensorKitSectors.LargeZNIrrep</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct LargeZNIrrep{N} &lt;: AbstractIrrep{‚Ñ§{N}}
LargeZNIrrep{N}(n::Integer)
Irrep[‚Ñ§{N}](n::Integer)</code></pre><p>Represents irreps of the group <span>$‚Ñ§_N$</span> for some value of <code>N</code>, which is typically larger than 128. For smaller values of <code>N</code>, the <a href="#TensorKitSectors.ZNIrrep"><code>ZNIrrep</code></a> sector type should be used instead. An arbitrary <code>Integer</code> <code>n</code> can be provided to the constructor, but only the value <code>mod(n, N)</code> is relevant.</p><p>The constructor <code>Irrep[‚Ñ§{N}]</code> should be preferred, as it will automatically select the most efficient storage type for a given value of <code>N</code>.</p><p>See also <a href="#TensorKitSectors.charge-Tuple{U1Irrep}"><code>charge</code></a> and <a href="#TensorKitSectors.modulus-Tuple{Union{LargeZNIrrep{N}, ZNIrrep{N}} where N}"><code>modulus</code></a> to extract the relevant data.</p><p><strong>Fields</strong></p><ul><li><code>n::UInt</code>: the integer label of the irrep, modulo <code>N</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/irreps/znirrep.jl#L30-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.NoBraiding"><a class="docstring-binding" href="#TensorKitSectors.NoBraiding"><code>TensorKitSectors.NoBraiding</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type BradingStyle
BraidingStyle(::Sector) -&gt; ::BraidingStyle
BraidingStyle(I::Type{&lt;:Sector}) -&gt; ::BraidingStyle</code></pre><p>Return the type of braiding and twist behavior of sectors of type <code>I</code>, which can be either</p><ul><li><code>NoBraiding()</code>: no braiding structure</li><li><code>Bosonic()</code>: symmetric braiding with trivial twist (i.e. identity)</li><li><code>Fermionic()</code>: symmetric braiding with non-trivial twist (squares to identity)</li><li><code>Anyonic()</code>: general <span>$R^{ab}_c$</span> phase or matrix (depending on <code>SimpleFusion</code> or   <code>GenericFusion</code> fusion) and arbitrary twists</li></ul><p>Note that <code>Bosonic</code> and <code>Fermionic</code> are subtypes of <code>SymmetricBraiding</code>, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: <code>isone(Rsymbol(b,a,c)*Rsymbol(a,b,c)) == true</code>) and permutations are uniquely defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L571-L586">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.PlanarTrivial"><a class="docstring-binding" href="#TensorKitSectors.PlanarTrivial"><code>TensorKitSectors.PlanarTrivial</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct PlanarTrivial &lt;: Sector
PlanarTrivial()</code></pre><p>Represents a trivial anyon sector, i.e. a trivial sector without braiding. This is mostly useful for testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/anyons.jl#L5-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.ProductGroup"><a class="docstring-binding" href="#TensorKitSectors.ProductGroup"><code>TensorKitSectors.ProductGroup</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type ProductGroup{T &lt;: Tuple{Vararg{Group}}} &lt;: Group</code></pre><p>Type to represent the direct product of a tuple of groups. This is typically constructed via the <a href="#TensorKitSectors.:√ó-Tuple{Vararg{Type{&lt;:Group}}}"><code>√ó</code></a> operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/groups.jl#L99-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.ProductSector"><a class="docstring-binding" href="#TensorKitSectors.ProductSector"><code>TensorKitSectors.ProductSector</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ProductSector{T &lt;: SectorTuple}
ProductSector((s‚ÇÅ, s‚ÇÇ, ...))</code></pre><p>Represents the Deligne tensor product of sectors. The type parameter <code>T</code> is a tuple of the component sectors. The recommended way to construct a <code>ProductSector</code> is using the <a href="#TensorKitSectors.:‚ä†-Tuple{Sector, Sector}"><code>deligneproduct</code></a> (<code>‚ä†</code>) operator on the components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/product.jl#L5-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.SU"><a class="docstring-binding" href="#TensorKitSectors.SU"><code>TensorKitSectors.SU</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type SU{N} &lt;: Group</code></pre><p>Type to represent the special unitary group <span>$SU(N)$</span>, which is a compact non-Abelian Lie group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/groups.jl#L58-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.SU2Irrep"><a class="docstring-binding" href="#TensorKitSectors.SU2Irrep"><code>TensorKitSectors.SU2Irrep</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SU2Irrep &lt;: AbstractIrrep{SU‚ÇÇ}
SU2Irrep(j::Real)
Irrep[SU‚ÇÇ](j::Real)</code></pre><p>Represents irreps of the group <span>$SU‚ÇÇ$</span>. The irrep is labelled by a half integer <code>j</code> which can be entered as an abitrary <code>Real</code>, but is stored as a <code>HalfInt</code> from the HalfIntegers.jl package.</p><p><strong>Fields</strong></p><ul><li><code>j::HalfInt</code>: the label of the irrep, which can be any non-negative half integer.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/irreps/su2irrep.jl#L1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Sector"><a class="docstring-binding" href="#TensorKitSectors.Sector"><code>TensorKitSectors.Sector</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type Sector</code></pre><p>Abstract type for representing the (isomorphism classes of) simple objects in (unitary and pivotal) (pre-)fusion categories, e.g. the irreducible representations of a finite or compact group. Subtypes <code>I &lt;: Sector</code> as the set of labels of a <code>GradedSpace</code>.</p><p>Every new <code>I &lt;: Sector</code> should implement the following methods:</p><ul><li><code>unit(::Type{I})</code>: unit element of <code>I</code>. If there are multiple, implement <code>allunits(::Type{I})</code>   instead.</li><li><code>dual(a::I)</code>: <span>$aÃÖ$</span>, conjugate or dual label of <span>$a$</span></li><li><code>‚äó(a::I, b::I)</code>: iterable with unique fusion outputs of <span>$a ‚äó b$</span>   (i.e. don&#39;t repeat in case of multiplicities)</li><li><code>Nsymbol(a::I, b::I, c::I)</code>: number of times <code>c</code> appears in <code>a ‚äó b</code>, i.e. the   multiplicity</li><li><code>FusionStyle(::Type{I})</code>: <code>UniqueFusion()</code>, <code>SimpleFusion()</code> or   <code>GenericFusion()</code></li><li><code>BraidingStyle(::Type{I})</code>: <code>Bosonic()</code>, <code>Fermionic()</code>, <code>Anyonic()</code>, ...</li><li><code>Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I)</code>: F-symbol: scalar (in case of   <code>UniqueFusion</code>/<code>SimpleFusion</code>) or rank-4 array (in case of <code>GenericFusion</code>)</li><li><code>Rsymbol(a::I, b::I, c::I)</code>: R-symbol: scalar (in case of   <code>UniqueFusion</code>/<code>SimpleFusion</code>) or matrix (in case of <code>GenericFusion</code>)</li><li><code>isless(a::I, b::I)</code>: defines a canonical ordering of sectors</li><li><code>hash(a::I)</code>: hash function for sectors</li></ul><p>and optionally</p><ul><li><code>dim(a::I)</code>: quantum dimension of sector <code>a</code></li><li><code>frobenius_schur_indicator(a::I)</code>: Frobenius-Schur indicator of <code>a</code> (1, 0, -1)</li><li><code>frobenius_schur_phase(a::I)</code>: Frobenius-Schur phase of <code>a</code> (¬±1)</li><li><code>sectorscalartype(::Type{I})</code>: scalar type of F- and R-symbols</li><li><code>Bsymbol(a::I, b::I, c::I)</code>: B-symbol: scalar (in case of   <code>UniqueFusion</code>/<code>SimpleFusion</code>) or matrix (in case of <code>GenericFusion</code>)</li><li><code>twist(a::I)</code> -&gt; twist of sector <code>a</code></li></ul><p>Furthermore, <code>iterate</code> and <code>Base.IteratorSize</code> should be made to work for the singleton type <a href="#TensorKitSectors.SectorValues"><code>SectorValues{I}</code></a>.</p><p>To help with the implementation of <code>‚äó(a::I, b::I)</code> as an iterator, the provided <code>struct</code> type <a href="#TensorKitSectors.SectorProductIterator"><code>SectorProductIterator{I}</code></a> can be used, which stores <code>a</code> and <code>b</code> and requires the implementation of <code>Base.iterate(::SectorProductIterator{I}, state...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L1-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.SectorProductIterator"><a class="docstring-binding" href="#TensorKitSectors.SectorProductIterator"><code>TensorKitSectors.SectorProductIterator</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SectorProductIterator{I &lt;: Sector}
SectorProductIterator(a::I, b::I) where {I &lt;: Sector}</code></pre><p>Custom iterator to represent the (unique) fusion outputs of <span>$a ‚äó b$</span>.</p><p>Custom sectors that aim to use this have to provide the following functionality:</p><ul><li><code>Base.iterate(::SectorProductIterator{I}, state...) where {I &lt;: Sector}</code>: iterate over   the fusion outputs of <code>a ‚äó b</code></li></ul><p>If desired and it is possible to easily compute the number of unique fusion outputs, it is also possible to define <code>Base.IteratorSize(::Type{SectorProductIterator{I}}) = Base.HasLength()</code>, in which case <code>Base.length(::SectorProductIterator{I})</code> has to be implemented.</p><p>See also <a href="#TensorKitSectors.:‚äó"><code>‚äó</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L248-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.SectorValues"><a class="docstring-binding" href="#TensorKitSectors.SectorValues"><code>TensorKitSectors.SectorValues</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SectorValues{I &lt;: Sector}</code></pre><p>Singleton type to represent an iterator over the possible values of type <code>I</code>, whose instance is obtained as <code>values(I)</code>. For a new <code>I::Sector</code>, the following should be defined</p><ul><li><code>Base.iterate(::SectorValues{I}[, state])</code>: iterate over the values</li><li><code>Base.IteratorSize(::Type{SectorValues{I}})</code>: <code>HasLength()</code>, <code>SizeUnknown()</code>   or <code>IsInfinite()</code> depending on whether the number of values of type <code>I</code> is finite   (and sufficiently small) or infinite; for a large number of values, <code>SizeUnknown()</code> is   recommended because this will trigger the use of <code>GenericGradedSpace</code>.</li></ul><p>If <code>IteratorSize(I) == HasLength()</code>, also the following must be implemented:</p><ul><li><code>Base.length(::SectorValues{I})</code>: the number of different values</li><li><code>Base.getindex(::SectorValues{I}, i::Int)</code>: a mapping between an index <code>i</code> and an   instance of <code>I</code>. A fallback implementation exists that returns the <code>i</code>th value   of the <code>SectorValues</code> iterator.</li><li><code>findindex(::SectorValues{I}, c::I)</code>: reverse mapping between a value <code>c::I</code> and an   index <code>i::Integer ‚àà 1:length(values(I))</code>. A fallback implementation exists that   linearly searches through the <code>SectorValues</code> iterator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L53-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.SimpleFusion"><a class="docstring-binding" href="#TensorKitSectors.SimpleFusion"><code>TensorKitSectors.SimpleFusion</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type FusionStyle
FusionStyle(::Sector)
FusionStyle(I::Type{&lt;:Sector})</code></pre><p>Trait to describe the fusion behavior of sectors of type <code>I</code>, which can be either</p><ul><li><code>UniqueFusion()</code>: single fusion output when fusing two sectors;</li><li><code>SimpleFusion()</code>: multiple outputs, but every output occurs at most one,   also known as multiplicity-free (e.g. irreps of <span>$SU(2)$</span>);</li><li><code>GenericFusion()</code>: multiple outputs that can occur more than once (e.g. irreps   of <span>$SU(3)$</span>).</li></ul><p>There is an abstract supertype <code>MultipleFusion</code> of which both <code>SimpleFusion</code> and <code>GenericFusion</code> are subtypes. Furthermore, there is a type alias <code>MultiplicityFreeFusion</code> for those fusion types which do not require muliplicity labels, i.e. <code>MultiplicityFreeFusion = Union{UniqueFusion,SimpleFusion}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L306-L322">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.SimpleUnit"><a class="docstring-binding" href="#TensorKitSectors.SimpleUnit"><code>TensorKitSectors.SimpleUnit</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type UnitStyle
UnitStyle(::Sector)
UnitStyle(I::Type{&lt;:Sector})</code></pre><p>Trait to describe the semisimplicity of the unit sector of type <code>I</code>. This can be either</p><ul><li><code>SimpleUnit()</code>: the unit is simple (e.g. fusion categories);</li><li><code>GenericUnit()</code>: the unit is semisimple.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L345-L354">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.TimeReversed"><a class="docstring-binding" href="#TensorKitSectors.TimeReversed"><code>TensorKitSectors.TimeReversed</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TimeReversed{I &lt;: Sector}
TimeReversed(a::Sector)
timereversed(a::Sector)</code></pre><p>Represents the time-reversed version of the sector <code>a</code>, i.e. the sector with the same fusion rules and <code>F</code>-symbols, but with the inverse braiding. Time reversal acts trivially on sectors with symmetric braiding. In such cases, <code>timereversed(a)</code> simply returns <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/timereversed.jl#L3-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Trivial"><a class="docstring-binding" href="#TensorKitSectors.Trivial"><code>TensorKitSectors.Trivial</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Trivial &lt;: Sector
Trivial()</code></pre><p>Singleton type to represent the trivial sector, i.e. the trivial representation of the trivial group. This is equivalent to <code>Rep[‚Ñ§‚ÇÅ]</code>, or the unit object of the category <code>Vect</code> of ordinary vector spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/trivial.jl#L1-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.U1Irrep"><a class="docstring-binding" href="#TensorKitSectors.U1Irrep"><code>TensorKitSectors.U1Irrep</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct U1Irrep &lt;: AbstractIrrep{U‚ÇÅ}
U1Irrep(charge::Real)
Irrep[U‚ÇÅ](charge::Real)</code></pre><p>Represents irreps of the group <span>$U‚ÇÅ$</span>. The irrep is labelled by a charge, which should be an integer for a linear representation. However, it is often useful to allow half integers to represent irreps of <span>$U‚ÇÅ$</span> subgroups of <span>$SU‚ÇÇ$</span>, such as the <span>$S^z$</span> of spin-1/2 system. Hence, the charge is stored as a <code>HalfInt</code> from the package HalfIntegers.jl, but can be entered as arbitrary <code>Real</code>. The sequence of the charges is: 0, 1/2, -1/2, 1, -1, ...</p><p><strong>Fields</strong></p><ul><li><code>charge::HalfInt</code>: the label of the irrep, which can be any half integer.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/irreps/u1irrep.jl#L2-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.UniqueFusion"><a class="docstring-binding" href="#TensorKitSectors.UniqueFusion"><code>TensorKitSectors.UniqueFusion</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type FusionStyle
FusionStyle(::Sector)
FusionStyle(I::Type{&lt;:Sector})</code></pre><p>Trait to describe the fusion behavior of sectors of type <code>I</code>, which can be either</p><ul><li><code>UniqueFusion()</code>: single fusion output when fusing two sectors;</li><li><code>SimpleFusion()</code>: multiple outputs, but every output occurs at most one,   also known as multiplicity-free (e.g. irreps of <span>$SU(2)$</span>);</li><li><code>GenericFusion()</code>: multiple outputs that can occur more than once (e.g. irreps   of <span>$SU(3)$</span>).</li></ul><p>There is an abstract supertype <code>MultipleFusion</code> of which both <code>SimpleFusion</code> and <code>GenericFusion</code> are subtypes. Furthermore, there is a type alias <code>MultiplicityFreeFusion</code> for those fusion types which do not require muliplicity labels, i.e. <code>MultiplicityFreeFusion = Union{UniqueFusion,SimpleFusion}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L306-L322">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.UnitStyle"><a class="docstring-binding" href="#TensorKitSectors.UnitStyle"><code>TensorKitSectors.UnitStyle</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type UnitStyle
UnitStyle(::Sector)
UnitStyle(I::Type{&lt;:Sector})</code></pre><p>Trait to describe the semisimplicity of the unit sector of type <code>I</code>. This can be either</p><ul><li><code>SimpleUnit()</code>: the unit is simple (e.g. fusion categories);</li><li><code>GenericUnit()</code>: the unit is semisimple.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L345-L354">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.U‚ÇÅ"><a class="docstring-binding" href="#TensorKitSectors.U‚ÇÅ"><code>TensorKitSectors.U‚ÇÅ</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type U‚ÇÅ &lt;: AbelianGroup</code></pre><p>Type to represent the group <span>$U(1)$</span> of complex numbers of unit modulus, which is a compact Abelian Lie group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/groups.jl#L50-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.ZNElement"><a class="docstring-binding" href="#TensorKitSectors.ZNElement"><code>TensorKitSectors.ZNElement</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ZNElement{N, p} &lt;: AbstractGroupElement{‚Ñ§{N}}
ZNElement{N, p}(n::Integer)
GroupElement[‚Ñ§{N}, p](n::Integer)</code></pre><p>Represents an element of the group <span>$‚Ñ§_N$</span> for some value of <code>N &lt; 64</code>. (We need <code>2 * (N - 1) &lt;= 127</code> in order for <code>a ‚äó b</code> to work correctly.) For <code>N</code> equals <code>2</code>, <code>3</code> or <code>4</code>, <code>‚Ñ§{N}</code> can be replaced by <code>‚Ñ§‚ÇÇ</code>, <code>‚Ñ§‚ÇÉ</code>, <code>‚Ñ§‚ÇÑ</code>. An arbitrary <code>Integer</code> <code>n</code> can be provided to the constructor, but only the value <code>mod(n, N)</code> is relevant. The second type parameter <code>p</code> should also be specified as an integer <code>0 &lt;= p &lt; N</code> and specifies the 3-cocycle, which is then being given by</p><pre><code class="language-julia hljs">cocycle(a, b, c) = cispi(2 * p * a.n * (b.n + c.n - mod(b.n + c.n, N)) / N))</code></pre><p>If <code>p</code> is not specified, it defaults to <code>0</code>, i.e. the trivial cocycle.</p><p><strong>Fields</strong></p><ul><li><code>n::Int8</code>: the integer label of the element, modulo <code>N</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/groupelements.jl#L90-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.ZNIrrep"><a class="docstring-binding" href="#TensorKitSectors.ZNIrrep"><code>TensorKitSectors.ZNIrrep</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ZNIrrep{N} &lt;: AbstractIrrep{‚Ñ§{N}}
ZNIrrep{N}(n::Integer)
Irrep[‚Ñ§{N}](n::Integer)</code></pre><p>Represents irreps of the group <span>$‚Ñ§_N$</span> for some value of <code>N</code>. For <code>N</code> equals <code>2</code>, <code>3</code> or <code>4</code>, <code>‚Ñ§{N}</code> can be replaced by <code>‚Ñ§‚ÇÇ</code>, <code>‚Ñ§‚ÇÉ</code>, and <code>‚Ñ§‚ÇÑ</code>. An arbitrary <code>Integer</code> <code>n</code> can be provided to the constructor, but only the value <code>mod(n, N)</code> is relevant.</p><p>The type of the stored integer (<code>UInt8</code>) requires <code>N ‚â§ 128</code>. Larger values of <code>N</code> should use the <a href="#TensorKitSectors.LargeZNIrrep"><code>LargeZNIrrep</code></a> instead. The constructor <code>Irrep[‚Ñ§{N}]</code> should be preferred, as it will automatically select the most efficient storage type for a given value of <code>N</code>.</p><p>See also <a href="#TensorKitSectors.charge-Tuple{U1Irrep}"><code>charge</code></a> and <a href="#TensorKitSectors.modulus-Tuple{Union{LargeZNIrrep{N}, ZNIrrep{N}} where N}"><code>modulus</code></a> to extract the relevant data.</p><p><strong>Fields</strong></p><ul><li><code>n::UInt8</code>: the integer label of the irrep, modulo <code>N</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/irreps/znirrep.jl#L4-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isreal-Tuple{Type{&lt;:Sector}}"><a class="docstring-binding" href="#Base.isreal-Tuple{Type{&lt;:Sector}}"><code>Base.isreal</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isreal(::Type{&lt;:Sector}) -&gt; Bool</code></pre><p>Return whether the topological data (Fsymbol, Rsymbol) of the sector is real or not (in which case it is complex).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L208-L213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.:√ó-Tuple{Vararg{Type{&lt;:Group}}}"><a class="docstring-binding" href="#TensorKitSectors.:√ó-Tuple{Vararg{Type{&lt;:Group}}}"><code>TensorKitSectors.:√ó</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">√ó(G::Vararg{Type{&lt;:Group}}) -&gt; ProductGroup{Tuple{G...}}
times(G::Vararg{Type{&lt;:Group}}) -&gt; ProductGroup{Tuple{G...}}</code></pre><p>Construct the direct product of a (list of) groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/groups.jl#L107-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.:‚äó"><a class="docstring-binding" href="#TensorKitSectors.:‚äó"><code>TensorKitSectors.:‚äó</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">‚äó(a::I, b::I...) where {I &lt;: Sector}
otimes(a::I, b::I...) where {I &lt;: Sector}</code></pre><p>Return an iterable of elements of <code>c::I</code> that appear in the fusion product <code>a ‚äó b</code>.</p><p>Note that every element <code>c</code> should appear at most once, fusion degeneracies (if <code>FusionStyle(I) == GenericFusion()</code>) should be accessed via <code>Nsymbol(a, b, c)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L218-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.:‚ä†-Tuple{Sector, Sector}"><a class="docstring-binding" href="#TensorKitSectors.:‚ä†-Tuple{Sector, Sector}"><code>TensorKitSectors.:‚ä†</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">‚ä†(s‚ÇÅ::Sector, s‚ÇÇ::Sector)
deligneproduct(s‚ÇÅ::Sector, s‚ÇÇ::Sector)</code></pre><p>Given two sectors <code>s‚ÇÅ</code> and <code>s‚ÇÇ</code>, which label an isomorphism class of simple objects in a fusion category <span>$C‚ÇÅ$</span> and <span>$C‚ÇÇ$</span>, <code>s1 ‚ä† s2</code> (obtained as <code>\boxtimes+TAB</code>) labels the isomorphism class of simple objects in the Deligne tensor product category <span>$C‚ÇÅ ‚ä† C‚ÇÇ$</span>.</p><p>The Deligne tensor product also works in the type domain and for spaces and tensors. For group representations, we have <code>Irrep[G‚ÇÅ] ‚ä† Irrep[G‚ÇÇ] == Irrep[G‚ÇÅ √ó G‚ÇÇ]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/product.jl#L262-L272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Asymbol-Union{Tuple{I}, Tuple{I, I, I}} where I&lt;:Sector"><a class="docstring-binding" href="#TensorKitSectors.Asymbol-Union{Tuple{I}, Tuple{I, I, I}} where I&lt;:Sector"><code>TensorKitSectors.Asymbol</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Asymbol(a::I, b::I, c::I) where {I &lt;: Sector}</code></pre><p>Return the value of <span>$A^{ab}_c$</span> which appears in transforming a splitting vertex into a fusion vertex using the transformation</p><pre><code class="language-julia hljs">a -&lt;-Œº-&lt;- c                                                    b -&lt;-ŒΩ-&lt;- dual(a)
     ‚à®       -&gt; ‚àö(dim(c) / dim(b)) * Asymbol(a, b, c)[Œº, ŒΩ]         ‚àß
     b                                                              c</code></pre><p>If <code>FusionStyle(I)</code> is <code>UniqueFusion()</code> or <code>SimpleFusion()</code>, the A-symbol is a number. Otherwise it is a square matrix with row and column size <code>Nsymbol(a, b, c) == Nsymbol(dual(a), c, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L485-L498">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Bsymbol-Union{Tuple{I}, Tuple{I, I, I}} where I&lt;:Sector"><a class="docstring-binding" href="#TensorKitSectors.Bsymbol-Union{Tuple{I}, Tuple{I, I, I}} where I&lt;:Sector"><code>TensorKitSectors.Bsymbol</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Bsymbol(a::I, b::I, c::I) where {I &lt;: Sector}</code></pre><p>Return the value of <span>$B^{ab}_c$</span> which appears in transforming a splitting vertex into a fusion vertex using the transformation</p><pre><code class="language-julia hljs">a -&lt;-Œº-&lt;- c                                                    a -&lt;-ŒΩ-&lt;- c
     ‚à®       -&gt; ‚àö(dim(c) / dim(a)) * Bsymbol(a, b, c)[Œº, ŒΩ]         ‚àß
     b                                                            dual(b)</code></pre><p>If <code>FusionStyle(I)</code> is <code>UniqueFusion()</code> or <code>SimpleFusion()</code>, the B-symbol is a number. Otherwise it is a square matrix with row and column size <code>Nsymbol(a, b, c) == Nsymbol(c, dual(b), a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L527-L540">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Fsymbol"><a class="docstring-binding" href="#TensorKitSectors.Fsymbol"><code>TensorKitSectors.Fsymbol</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I &lt;: Sector}</code></pre><p>Return the F-symbol <span>$F^{abc}_d$</span> that associates the two different fusion orders of sectors <code>a</code>, <code>b</code> and <code>c</code> into an ouput sector <code>d</code>, using either an intermediate sector <span>$a ‚äó b ‚Üí e$</span> or <span>$b ‚äó c ‚Üí f$</span>:</p><pre><code class="language-julia hljs">a-&lt;-Œº-&lt;-e-&lt;-ŒΩ-&lt;-d                                     a-&lt;-Œª-&lt;-d
    ‚à®       ‚à®       -&gt; Fsymbol(a,b,c,d,e,f)[Œº,ŒΩ,Œ∫,Œª]      ‚à®
    b       c                                             f
                                                          v
                                                      b-&lt;-Œ∫
                                                          ‚à®
                                                          c</code></pre><p>If <code>FusionStyle(I)</code> is <code>UniqueFusion</code> or <code>SimpleFusion</code>, the F-symbol is a number. Otherwise it is a rank 4 array of size <code>(Nsymbol(a, b, e), Nsymbol(e, c, d), Nsymbol(b, c, f), Nsymbol(a, f, d))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L385-L403">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Nsymbol"><a class="docstring-binding" href="#TensorKitSectors.Nsymbol"><code>TensorKitSectors.Nsymbol</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Nsymbol(a::I, b::I, c::I) where {I &lt;: Sector} -&gt; Integer</code></pre><p>Return an <code>Integer</code> representing the number of times <code>c</code> appears in the fusion product <code>a ‚äó b</code>. Could be a <code>Bool</code> if <code>FusionStyle(I) == UniqueFusion()</code> or <code>SimpleFusion()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L297-L302">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.Rsymbol"><a class="docstring-binding" href="#TensorKitSectors.Rsymbol"><code>TensorKitSectors.Rsymbol</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Rsymbol(a::I, b::I, c::I) where {I &lt;: Sector}</code></pre><p>Returns the R-symbol <span>$R^{ab}_c$</span> that maps between <span>$c ‚Üí a ‚äó b$</span> and <span>$c ‚Üí b ‚äó a$</span> as in</p><pre><code class="language-julia hljs">a -&lt;-Œº-&lt;- c                                 b -&lt;-ŒΩ-&lt;- c
     ‚à®        -&gt; Rsymbol(a, b, c)[Œº, ŒΩ]          v
     b                                           a</code></pre><p>If <code>FusionStyle(I)</code> is <code>UniqueFusion()</code> or <code>SimpleFusion()</code>, the R-symbol is a number. Otherwise it is a square matrix with row and column size <code>Nsymbol(a, b, c) == Nsymbol(b, a, c)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L611-L623">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.allunits-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><a class="docstring-binding" href="#TensorKitSectors.allunits-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><code>TensorKitSectors.allunits</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">allunits(I::Type{&lt;:Sector}) -&gt; Tuple{I}</code></pre><p>Return a tuple with all units of the sector type <code>I</code>. For fusion categories, this will contain only one element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L106-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.braidingscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><a class="docstring-binding" href="#TensorKitSectors.braidingscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><code>TensorKitSectors.braidingscalartype</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">braidingscalartype(I::Type{&lt;:Sector}) -&gt; Type{&lt;:Number}</code></pre><p>Return the scalar type of the topological data associated to braiding of the sector <code>I</code>. In particular, this is the scalar type of <a href="#TensorKitSectors.Rsymbol"><code>Rsymbol</code></a>.</p><p>See also <a href="#TensorKitSectors.fusionscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><code>fusionscalartype</code></a> and <a href="#TensorKitSectors.sectorscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><code>sectorscalartype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L194-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.charge-Tuple{U1Irrep}"><a class="docstring-binding" href="#TensorKitSectors.charge-Tuple{U1Irrep}"><code>TensorKitSectors.charge</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">charge(c::U1Irrep) -&gt; HalfInt</code></pre><p>The charge label of the irrep <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/irreps/u1irrep.jl#L22-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.charge-Tuple{Union{LargeZNIrrep{N}, ZNIrrep{N}} where N}"><a class="docstring-binding" href="#TensorKitSectors.charge-Tuple{Union{LargeZNIrrep{N}, ZNIrrep{N}} where N}"><code>TensorKitSectors.charge</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">charge(c::ZNIrrep) -&gt; Int</code></pre><p>The charge label of the irrep <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/irreps/znirrep.jl#L69-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.dim-Tuple{Sector}"><a class="docstring-binding" href="#TensorKitSectors.dim-Tuple{Sector}"><code>TensorKitSectors.dim</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dim(a::Sector)</code></pre><p>Return the (quantum) dimension of the sector <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L424-L428">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.dimscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><a class="docstring-binding" href="#TensorKitSectors.dimscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><code>TensorKitSectors.dimscalartype</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dimscalartype(::Type{&lt;:Sector}) -&gt; Type{&lt;:Number}</code></pre><p>Return the scalar type of the quantum dimensions associated to sectors of type <code>I</code>. In particular, this is the scalar type of <a href="#TensorKitSectors.dim-Tuple{Sector}"><code>dim</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L443-L448">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.dual-Tuple{Sector}"><a class="docstring-binding" href="#TensorKitSectors.dual-Tuple{Sector}"><code>TensorKitSectors.dual</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dual(a::Sector) -&gt; Sector</code></pre><p>Return the dual label of <code>a</code>, i.e. the unique label <code>aÃÑ = dual(a)</code> such that  <code>Nsymbol(a, aÃÑ, leftunit(a)) == 1</code> and <code>Nsymbol(aÃÑ, a, rightunit(a)) == 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L156-L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.findindex-Union{Tuple{I}, Tuple{SectorValues{I}, I}} where I&lt;:Sector"><a class="docstring-binding" href="#TensorKitSectors.findindex-Union{Tuple{I}, Tuple{SectorValues{I}, I}} where I&lt;:Sector"><code>TensorKitSectors.findindex</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">findindex(v::SectorValues{I}, c::I)</code></pre><p>Reverse mapping between a value <code>c::I</code> and an index <code>i::Integer ‚àà 1:length(values(I))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L93-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.frobenius_schur_indicator-Tuple{Sector}"><a class="docstring-binding" href="#TensorKitSectors.frobenius_schur_indicator-Tuple{Sector}"><code>TensorKitSectors.frobenius_schur_indicator</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">frobenius_schur_indicator(a::Sector)</code></pre><p>Return the Frobenius-Schur indicator of a sector <span>$ŒΩ‚Çê ‚àà \{1, 0, -1\}$</span>, which distinguishes between real, complex and quaternionic representations.</p><p>See also <a href="#TensorKitSectors.frobenius_schur_phase-Tuple{Sector}"><code>frobenius_schur_phase</code></a> for the category-theoretic version that appears in the context of line bending.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L471-L479">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.frobenius_schur_phase-Tuple{Sector}"><a class="docstring-binding" href="#TensorKitSectors.frobenius_schur_phase-Tuple{Sector}"><code>TensorKitSectors.frobenius_schur_phase</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">frobenius_schur_phase(a::Sector)</code></pre><p>Return the Frobenius-Schur phase <span>$Œ∫‚Çê$</span> of a sector <span>$a$</span>, which is a complex phase that appears in the context of bending lines and is obtained from <span>$F^{a aÃÖ a}_a$</span>. When <code>a == dual(a)</code>, it is restricted to <span>$Œ∫‚Çê ‚àà \{1, -1\}$</span> and coincides with the group-theoretic version <a href="#TensorKitSectors.frobenius_schur_indicator-Tuple{Sector}"><code>frobenius_schur_indicator</code></a>. When <code>a != dual(a)</code>, the value of <span>$Œ∫‚Çê$</span> can be gauged to be <code>1</code>, though is not required to be.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L452-L460">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.fusionscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><a class="docstring-binding" href="#TensorKitSectors.fusionscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><code>TensorKitSectors.fusionscalartype</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fusionscalartype(I::Type{&lt;:Sector}) -&gt; Type{&lt;:Number}</code></pre><p>Return the scalar type of the topological data associated to fusion of the sector <code>I</code>. In particular, this is the scalar type of <a href="#TensorKitSectors.Fsymbol"><code>Fsymbol</code></a>.</p><p>See also <a href="#TensorKitSectors.braidingscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><code>braidingscalartype</code></a> and <a href="#TensorKitSectors.sectorscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><code>sectorscalartype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L181-L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.fusiontensor-Union{Tuple{I}, Tuple{I, I, I}} where I&lt;:Sector"><a class="docstring-binding" href="#TensorKitSectors.fusiontensor-Union{Tuple{I}, Tuple{I, I, I}} where I&lt;:Sector"><code>TensorKitSectors.fusiontensor</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fusiontensor(a::I, b::I, c::I) where {I &lt;: Sector} -&gt; AbstractArray{T, 4}</code></pre><p>Return the fusion tensor for the fusion <code>a ‚äó b -&gt; c</code>. The dimensions of the returned array are <code>(dim(a), dim(b), dim(c), Nsymbol(a, b, c))</code>. The components of the fusion tensor are simply the Clebsch-Gordan coefficients, describing the unitary basis change from the tensor product of irreps <code>a</code> and <code>b</code> to the coupled irrep <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L376-L383">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.hexagon_equation-Union{Tuple{I}, Tuple{I, I, I}} where I&lt;:Sector"><a class="docstring-binding" href="#TensorKitSectors.hexagon_equation-Union{Tuple{I}, Tuple{I, I, I}} where I&lt;:Sector"><code>TensorKitSectors.hexagon_equation</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hexagon_equation(a::I, b::I, c::I; kwargs...) where {I &lt;: Sector} -&gt; Bool</code></pre><p>Check whether the hexagon equation holds for braiding the sector <code>a</code> around the fusion product of <code>b</code> and <code>c</code> along the two different paths.</p><p>If <code>kwargs</code> are provided, they are forwarded to <code>isapprox</code> when comparing the two sides of the hexagon equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L720-L728">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.isunit-Tuple{Sector}"><a class="docstring-binding" href="#TensorKitSectors.isunit-Tuple{Sector}"><code>TensorKitSectors.isunit</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isunit(a::Sector) -&gt; Bool</code></pre><p>Return whether sector <code>a</code> is a unit element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L124-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.leftunit-Tuple{Sector}"><a class="docstring-binding" href="#TensorKitSectors.leftunit-Tuple{Sector}"><code>TensorKitSectors.leftunit</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">leftunit(a::Sector) -&gt; Sector</code></pre><p>Return the left unit element corresponding to <code>a</code>; this is necessary for multifusion categories, where the unit may not be unique. See also <a href="#TensorKitSectors.rightunit-Tuple{Sector}"><code>rightunit</code></a> and <a href="#TensorKitSectors.unit-Tuple{Sector}"><code>unit</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L138-L144">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.modulus-Tuple{Union{LargeZNIrrep{N}, ZNIrrep{N}} where N}"><a class="docstring-binding" href="#TensorKitSectors.modulus-Tuple{Union{LargeZNIrrep{N}, ZNIrrep{N}} where N}"><code>TensorKitSectors.modulus</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">modulus(c::ZNIrrep{N}) -&gt; N
modulus(::Type{&lt;:ZNIrrep{N}}) -&gt; N</code></pre><p>The order of the cyclic group, or the modulus of the charge labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/irreps/znirrep.jl#L60-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.pentagon_equation-Union{Tuple{I}, NTuple{4, I}} where I&lt;:Sector"><a class="docstring-binding" href="#TensorKitSectors.pentagon_equation-Union{Tuple{I}, NTuple{4, I}} where I&lt;:Sector"><code>TensorKitSectors.pentagon_equation</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pentagon_equation(a::I, b::I, c::I, d::I; kwargs...) where {I &lt;: Sector} -&gt; Bool</code></pre><p>Check whether the pentagon equation holds for fusing the sectors <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> to each of their sectors along the two different fusion paths.</p><p>If <code>kwargs</code> are provided, they are forwarded to <code>isapprox</code> when comparing the two sides of the pentagon equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L673-L681">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.precompile_sector-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><a class="docstring-binding" href="#TensorKitSectors.precompile_sector-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><code>TensorKitSectors.precompile_sector</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">precompile_sector(I::Type{&lt;:Sector})</code></pre><p>Precompile common methods for the given sector type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/precompile.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.rightunit-Tuple{Sector}"><a class="docstring-binding" href="#TensorKitSectors.rightunit-Tuple{Sector}"><code>TensorKitSectors.rightunit</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rightunit(a::Sector) -&gt; Sector</code></pre><p>Return the right unit element corresponding to <code>a</code>; this is necessary for multifusion categories, where the unit may not be unique. See also <a href="#TensorKitSectors.leftunit-Tuple{Sector}"><code>leftunit</code></a> and <a href="#TensorKitSectors.unit-Tuple{Sector}"><code>unit</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L147-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.sectorscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><a class="docstring-binding" href="#TensorKitSectors.sectorscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><code>TensorKitSectors.sectorscalartype</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sectorscalartype(I::Type{&lt;:Sector}) -&gt; Type{&lt;:Number}</code></pre><p>Return the scalar type of the topological data of the sector <code>I</code>. In particular, this is a combination of the scalar type of both the <a href="#TensorKitSectors.Fsymbol"><code>Fsymbol</code></a> and <a href="#TensorKitSectors.Rsymbol"><code>Rsymbol</code></a>, and determines the scalar type of the <a href="#TensorKitSectors.fusiontensor-Union{Tuple{I}, Tuple{I, I, I}} where I&lt;:Sector"><code>fusiontensor</code></a> whenever it is defined.</p><p>See also <a href="#TensorKitSectors.fusionscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><code>fusionscalartype</code></a> and <a href="#TensorKitSectors.braidingscalartype-Union{Tuple{Type{I}}, Tuple{I}} where I&lt;:Sector"><code>braidingscalartype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L164-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.timereversed-Tuple{Sector}"><a class="docstring-binding" href="#TensorKitSectors.timereversed-Tuple{Sector}"><code>TensorKitSectors.timereversed</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">timereversed(a::Sector)</code></pre><p>Return the time-reversed version of the sector <code>a</code>.  If <code>a</code> is already a time-reversed sector, return the original sector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/timereversed.jl#L25-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.twist-Tuple{Sector}"><a class="docstring-binding" href="#TensorKitSectors.twist-Tuple{Sector}"><code>TensorKitSectors.twist</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">twist(a::Sector)</code></pre><p>Return the twist of a sector <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L641-L645">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.type_repr-Tuple{Type}"><a class="docstring-binding" href="#TensorKitSectors.type_repr-Tuple{Type}"><code>TensorKitSectors.type_repr</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">type_repr(T::Type)</code></pre><p>Return a string representation of the type <code>T</code>, which is used to modify the default way in which <code>Sector</code> subtypes are displayed in other objects that depend on them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L43-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.unit-Tuple{Sector}"><a class="docstring-binding" href="#TensorKitSectors.unit-Tuple{Sector}"><code>TensorKitSectors.unit</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unit(::Sector) -&gt; Sector
unit(::Type{&lt;:Sector}) -&gt; Sector</code></pre><p>Return the unit element of this type of sector, provided it is unique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/76682ceff8ef4426697672ed3cbb7b1b8267b9e9/src/sectors.jl#L114-L119">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Monday 23 February 2026 10:27">Monday 23 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
