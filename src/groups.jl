# Groups
#------------------------------------------------------------------------------#
"""
    abstract type Group

Abstract supertype for representing different types of groups. Groups can be used
to define Sector subtypes, either via their irreducible representations, or
via their group elements, and typically appear as type parameter. As such, they
are not meant to be instantiated and are defined as abstract types.
"""
abstract type Group end

"""
    abstract type AbelianGroup <: Group

Abstract supertype for representing different types of Abelian groups.
Abelian groups have both irreps and group elements that have several
simplified properties, that can be defined in general.
"""
abstract type AbelianGroup <: Group end

"""
    abstract type Cyclic{N} <: AbelianGroup

Type to represent the cyclic group of order `N`, i.e. the multiplicative
group of roots of unity of order `N`, which is a discrete abelian group.
The cyclic group of order `N` is isomorphic to the additive group `ℤ{N}`,
and we define the latter as a type alias `const ℤ{N} = Cyclic{N}`.
"""
abstract type Cyclic{N} <: AbelianGroup end

"""
    abstract type Dihedral{N} <: Group

Type to represent the dihedral group of order `2N`, which is the symmetry
group of a regular polygon with `N` sides, and is a discrete non-Abelian
group. 
"""
abstract type Dihedral{N} <: Group end

"""
    abstract type Alternating{N} <: Group

Type to represent the alternating group of order `N!/2`, which is the group
of even permutations on `N` elements. 
"""
abstract type Alternating{N} <: Group end


"""
    abstract type U₁ <: AbelianGroup

Type to represent the group ``U(1)`` of complex numbers of unit modulus,
which is a compact Abelian Lie group.
"""
abstract type U₁ <: AbelianGroup end

"""
    abstract type SU{N} <: Group

Type to represent the special unitary group ``SU(N)``, which is a
compact non-Abelian Lie group.
"""
abstract type SU{N} <: Group end

"""
    abstract type CU₁ <: Group

Type to represent the group of U₁ in combination with charge conjugation,
i.e. the group generated by U₁ and an additional element that acts as
complex conjugation on U₁. This group is isomorphic to the orthogonal group O₂
of real orthogonal 2×2 matrices, and can be seen as the semidirect product U₁ ⋊ ℤ₂.
This is a compact non-Abelian group.
"""
abstract type CU₁ <: Group end

const ℤ{N} = Cyclic{N}
const ℤ₂ = ℤ{2}
const ℤ₃ = ℤ{3}
const ℤ₄ = ℤ{4}
const D₃ = Dihedral{3}
const D₄ = Dihedral{4}
const A₄ = Alternating{4}
const SU₂ = SU{2}

type_repr(::Type{ℤ₂}) = "ℤ₂"
type_repr(::Type{ℤ₃}) = "ℤ₃"
type_repr(::Type{ℤ₄}) = "ℤ₄"
type_repr(::Type{ℤ{N}}) where {N} = "ℤ{$N}"
type_repr(::Type{D₃}) = "D₃"
type_repr(::Type{D₄}) = "D₄"
type_repr(::Type{A₄}) = "A₄"
type_repr(::Type{SU₂}) = "SU₂"
type_repr(::Type{U₁}) = "U₁"
type_repr(::Type{CU₁}) = "CU₁"

const GroupTuple = Tuple{Vararg{Group}}

"""
    abstract type ProductGroup{T <: Tuple{Vararg{Group}}} <: Group

Type to represent the direct product of a tuple of groups. This is typically
constructed via the [`×`](@ref) operator.
"""
abstract type ProductGroup{T <: GroupTuple} <: Group end

"""
    ×(G::Vararg{Type{<:Group}}) -> ProductGroup{Tuple{G...}}
    times(G::Vararg{Type{<:Group}}) -> ProductGroup{Tuple{G...}}

Construct the direct product of a (list of) groups.
"""
function ×(::Vararg{Type{<:Group}}) end
const times = ×

×(a::Type{<:Group}, b::Type{<:Group}, c::Type{<:Group}...) = ×(×(a, b), c...)
×(G::Type{<:Group}) = ProductGroup{Tuple{G}}
×(G1::Type{ProductGroup{Tuple{}}}, G2::Type{ProductGroup{T}}) where {T <: GroupTuple} = G2
function ×(
        G1::Type{ProductGroup{T1}}, G2::Type{ProductGroup{T2}}
    ) where {T1 <: GroupTuple, T2 <: GroupTuple}
    return Base.tuple_type_head(T1) × (ProductGroup{Base.tuple_type_tail(T1)} × G2)
end
×(G1::Type{ProductGroup{Tuple{}}}, G2::Type{<:Group}) = ProductGroup{Tuple{G2}}
function ×(G1::Type{ProductGroup{T}}, G2::Type{<:Group}) where {T <: GroupTuple}
    return Base.tuple_type_head(T) × (ProductGroup{Base.tuple_type_tail(T)} × G2)
end
function ×(G1::Type{<:Group}, G2::Type{ProductGroup{T}}) where {T <: GroupTuple}
    return ProductGroup{Base.tuple_type_cons(G1, T)}
end
×(G1::Type{<:Group}, G2::Type{<:Group}) = ProductGroup{Tuple{G1, G2}}

function type_repr(G::Type{<:ProductGroup})
    T = G.parameters[1]
    groups = T.parameters
    if length(groups) == 1
        s = "ProductGroup{Tuple{" * type_repr(groups[1]) * "}}"
    else
        s = "("
        for i in 1:length(groups)
            if i != 1
                s *= " × "
            end
            s *= type_repr(groups[i])
        end
        s *= ")"
    end
    return s
end
